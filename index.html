<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="放点随笔文章">
<meta property="og:type" content="website">
<meta property="og:title" content="唐洋洋的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="唐洋洋的个人博客">
<meta property="og:description" content="放点随笔文章">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="唐洋洋的个人博客">
<meta name="twitter:description" content="放点随笔文章">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 唐洋洋的个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">唐洋洋的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">\(^o^)/~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/Fetch初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/22/Fetch初探/" itemprop="url">
                  Fetch初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T13:34:00+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Html/" itemprop="url" rel="index">
                    <span itemprop="name">Html</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>fetch这个东西，之前也看到过有人介绍，但毕竟还是实验性阶段的东西，最近在看react-native的文档，讲到网络的地方，文档上是推荐地使用fetch，想必框架本身也对其有所封装。这里就先自己学习一下fetch相关的基础知识。<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="external">Fetch</a> 是一个现代的概念, 等同于<a href="https://developer.mozilla.org/enUS/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a>。它提供了许多与XMLHttpRequest相同的功能，但被设计成更具可扩展性和高效性。下图显示了fetch在浏览器中的支持情况，可以看到在主流浏览器的支持性还是不错的，实在不支持fetch的浏览器(比如IE)上面也可以使用相应的polyfill库。<br><img src="http://upload-images.jianshu.io/upload_images/6383319-9575a5a9c01ac1fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fetch在浏览器中的支持情况.png"><h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4></li>
<li><p>使用fetch首先需要具备promise的相关知识，还涉及到一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response" target="_blank" rel="external">Response</a>对象，直接来看下代码，这是一段调用json格式数据接口的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fetch(&apos;http://101.200.35.148:8081/todo/getTodo&apos;)</div><div class="line">  .then(response =&gt; &#123;</div><div class="line">    response.json().then(</div><div class="line">        // 这里的result就是最终的接口数据了</div><div class="line">        result =&gt; &#123;</div><div class="line">          console.log(result)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>在支持fetch的浏览器中，fetch方法是global的可以直接调用。上述代码是一个get请求(默认方法是get)，fetch执行后会返回一个promise对象，这个promise对象resolve之后得到一个response对象(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response" target="_blank" rel="external">Response</a>的实例)。</p>
</li>
<li><strong>response对象</strong>相当于整个流程中的一个中间状态，它自带一个json方法用于解析从接口得到的数据，还有一个属性bodyUsed标识是否已经被解析，response.json()执行后也是返回一个promise对象，正确执行后then()这里得到的result对象就是最终的接口数据了。执行完json方法后，response对象的bodyUsed会变成true，表示这个response对象是已经被读取过了的，这时候如果再次调用response的json方法就会报错。<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4></li>
<li><p>接着来看下fetch如何处理post请求，fetch方法可以接收第二个参数来设置发送请求的方法、header、请求参数等，下面是一个post请求的示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fetch(&quot;/post/api/&quot;, &#123;</div><div class="line">    method: &quot;POST&quot;,</div><div class="line">    body: &quot;A=参数A&amp;B=参数B&quot;,</div><div class="line">    headers: new Headers()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>其中body就表示请求参数，可根据具体情况自行调整数据结构;method设定请求方法，默认为get大小写皆可，headers用于设置发送请求的header。fetch在请求post的时候如果没有成功，则会尝试重新以get方法发送请求。</p>
<h4 id="使用async-await"><a href="#使用async-await" class="headerlink" title="使用async/await"></a>使用async/await</h4></li>
<li>因为多了一层response，这里的promise回调代码结构就略显复杂，所以用fetch时使用async/await代码就会精简许多，可读性也会大大提高，比如下面这样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">async componentDidMount () &#123;</div><div class="line">  try &#123;</div><div class="line">    let res = await fetch(&apos;http://101.200.35.148:8081/todo/getTodo&apos;)</div><div class="line">    let &#123;result&#125; = await res.json()</div><div class="line">    this.setState(&#123;</div><div class="line">      result</div><div class="line">    &#125;)</div><div class="line">  &#125; catch(e) &#123;</div><div class="line">    console.log(e)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h4><ul>
<li><p>fetch除了用于post/get调取接口以外还可以请求图片，下面是一段请求图片，然后将图片显示在dom上的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var myImage = document.querySelector(&apos;img&apos;);</div><div class="line"></div><div class="line">fetch(&apos;flowers.jpg&apos;)</div><div class="line">.then(function(response) &#123;</div><div class="line">  return response.blob();</div><div class="line">&#125;)</div><div class="line">.then(function(myBlob) &#123;</div><div class="line">  var objectURL = URL.createObjectURL(myBlob);</div><div class="line">  myImage.src = objectURL;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>可以看到代码第一步还是获取response对象，之后调用了response.blob()来得到一个blob对象，这里又涉及到了另一个新特性<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="external">Blob</a>，继续调用URL.createObjectURL可将blob对象转换为一个临时链接供img标签使用。Blob相关暂不多做介绍，这里只是为了说明一下fetch还有这一种用法。</p>
</li>
<li>参考： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/17/JavaScript中的-抽象语法树-AST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/17/JavaScript中的-抽象语法树-AST/" itemprop="url">
                  JavaScript中的 抽象语法树 AST
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-17T17:40:00+08:00">
                2017-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><ul>
<li>抽象语法树（Abstract Syntax Tree）也称为AST语法树，指的是源代码语法所对应的树状结构。也就是说，一种编程语言的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。 <img src="http://upload-images.jianshu.io/upload_images/6383319-b70c4cc018199852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图.png"></li>
<li>程序代码本身可以被映射成为一棵语法树，而通过操纵语法树，我们能够精准的获得程序代码中的每一个精确的节点。例如声明语句，赋值语句，而这是用正则表达式所不能准确体现的地方。<a href="http://esprima.org/demo/parse.html#" target="_blank" rel="external">esprima</a>提供了一个在线解析JavaScript代码的地址，可以清楚地观察到js代码被转化为JSON格式，由一个个具体的符号组成</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>抽象语法树的作用非常的多，比如编译器、IDE、压缩优化代码等。在JavaScript中，虽然我们并不会常常与AST直接打交道，但却也会经常的涉及到它。例如使用UglifyJS来压缩代码，实际这背后就是在对JavaScript的抽象语法树进行操作。<br><img src="http://upload-images.jianshu.io/upload_images/6383319-09faa2604367b873.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图2.png"></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/15/socket-io-实现在线聊天室/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/15/socket-io-实现在线聊天室/" itemprop="url">
                  socket.io 实现在线聊天室
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T10:20:00+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/6383319-ba462293ba9834bb.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图.gif"></p>
<ul>
<li><h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4></li>
<li>WebSocket协议是<strong>基于TCP</strong>的一种新的网络协议。它实现了<strong>浏览器与服务器全双工(full-duplex)通信</strong>——允许服务器主动发送信息给客户端。websocket链接建立后，服务端和客户端可通过连接通道自由通信。wx协议也有类似于https的wss协议，也是多了一层TLS协议。</li>
<li>websocket具体详细的内容就不多做介绍了，因为我这次使用的socket.io框架，写起来的语法和原生websocket语法还是有很大差别的。<h4 id="Socket-io简介"><a href="#Socket-io简介" class="headerlink" title="Socket.io简介"></a>Socket.io简介</h4></li>
<li>socket.io可以看做是一个对websocket进行了封装的一个框架，目的也是为了实现客户端和服务端的全双工通信。socket.io的底层是engine.io，engine.io在不支持websocket的浏览器中，会使用ajax的长轮询实现效果。</li>
<li>具体过程，浏览器和服务端首先建立xhr链接，第一次握手后，服务端返回浏览器一个upgrades字段，告诉前端可以升级为websocket协议，socket.io客户端的框架会进行环境监测支持websocket的话，就会将xhr链接升级为websocket。建立起一个websocket连接后，服务器和浏览器之间还会定期的ping-pong来确定网络链接是否正常。<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3></li>
<li>再来看下具体实现的代码如何写，<a href="https://socket.io/" target="_blank" rel="external">socket.io官网</a>上面的文档和教程还是挺详细的，而我们要实现这个多人聊天室也只需要其中一些比较基本的api即可。<h4 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h4></li>
<li><p>服务端我用的node，直接用Npm安装socket.io，可以用socket.io直接搭建服务器，也可以在原有的express/koa上部署，我之前用的express，这里就是将socket.io添加到原有的express服务器上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">let app = new (require(&apos;express&apos;))()</div><div class="line">const server = app.listen(8081, () =&gt; &#123;</div><div class="line">  let peopleCounts = 0</div><div class="line">  let io = require(&apos;socket.io&apos;)(server)</div><div class="line">  io.on(&apos;connection&apos;, function (client) &#123;</div><div class="line">    // 这里的作用域是局部的，针对一个窗口发起的ws链接</div><div class="line">    ++peopleCounts</div><div class="line">    let uname = &apos;&apos;</div><div class="line">    let uColor = require(&apos;./methods/util&apos;).getColor()</div><div class="line"></div><div class="line">    client.on(&apos;disconnect&apos;, function (e) &#123;</div><div class="line">      --peopleCounts</div><div class="line">      io.emit(&apos;sys message&apos;, &#123;</div><div class="line">        data: `系统消息: &quot;$&#123;uname&#125;&quot;离开聊天室`,</div><div class="line">        counts: peopleCounts</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    require(&apos;./methods/getNickName&apos;)()</div><div class="line">      .then(name =&gt; &#123;</div><div class="line">        uname = name</div><div class="line">        io.emit(&apos;initUser&apos;, &#123;</div><div class="line">          name,</div><div class="line">          color: uColor</div><div class="line">        &#125;)</div><div class="line">        io.emit(&apos;sys message&apos;, &#123;</div><div class="line">          data: `系统消息: &quot;$&#123;name&#125;&quot;进入聊天室`,</div><div class="line">          counts: peopleCounts</div><div class="line">        &#125;)</div><div class="line">      &#125;)</div><div class="line">      .catch(e =&gt; &#123; console.log(e) &#125;)</div><div class="line"></div><div class="line">    client.on(&apos;chat message&apos;, function (data) &#123;</div><div class="line">      io.emit(&apos;message from server&apos;, data)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">  console.log(&apos;Example app listening on port 8081!&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>在express服务器搭建成功的回调函数里绑定socket.io，这里的io变量就是表示socket.io的服务端。</p>
</li>
<li>.on方法监听事件，这些事件来自建立websocket连接时或者浏览器端主动触发。</li>
<li><p>.emit触发事件，前端可以监听这些事件。比如一个客户端连接到服务端时，服务端会生成一个随机昵称(getNickName方法非必要)，然后返回给客户端。</p>
<h4 id="客户端部署"><a href="#客户端部署" class="headerlink" title="客户端部署"></a>客户端部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">import io from &apos;socket.io-client&apos;</div><div class="line">export default &#123;</div><div class="line">  name: &apos;cheatRoom&apos;,</div><div class="line">  data () &#123;</div><div class="line">    return &#123;</div><div class="line">      description: &apos;&apos;,</div><div class="line">      nickName: &apos;&apos;,</div><div class="line">      counts: 1,</div><div class="line">      msg: [],</div><div class="line">      color: &apos;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  created () &#123;</div><div class="line">    window.vm = this</div><div class="line">    this.initSocket()</div><div class="line">  &#125;,</div><div class="line">  beforeDestroy () &#123;</div><div class="line">    // socket链接与vue生命周期绑定，vue销毁时手动断开socket链接</div><div class="line">    this.socket.close()</div><div class="line">  &#125;</div><div class="line">  methods: &#123;</div><div class="line">    initSocket () &#123;</div><div class="line">      const socket = io(this._config().preurl)</div><div class="line">      socket.on(&apos;connect&apos;, () =&gt; &#123;</div><div class="line">        this.socket = socket</div><div class="line">      &#125;)</div><div class="line">      // 这里api语法类似于jQuery,支持once监听一次,off取消监听</div><div class="line">      // [https://socket.io/docs/client-api/#socket-on-eventname-callback](https://socket.io/docs/client-api/#socket-on-eventname-callback)</div><div class="line">      socket.once(&apos;initUser&apos;, (&#123;name, color&#125;) =&gt; &#123;</div><div class="line">        this.nickName = name</div><div class="line">        this.color = color</div><div class="line">      &#125;)</div><div class="line">      socket.on(&apos;sys message&apos;, (&#123; data, counts &#125;) =&gt; &#123;</div><div class="line">        this.counts = counts</div><div class="line">        this.msg.push(&#123;</div><div class="line">          description: data,</div><div class="line">          sys: true</div><div class="line">        &#125;)</div><div class="line">      &#125;)</div><div class="line">      socket.on(&apos;message from server&apos;, (item) =&gt; &#123;</div><div class="line">        item.sys = false</div><div class="line">        this.msg.push(item)</div><div class="line">      &#125;)</div><div class="line">    &#125;,</div><div class="line">    loadAction () &#123;</div><div class="line">      let &#123; description, nickName, color &#125; = this</div><div class="line">      if (this.description.length === 0) &#123;</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line">      this.socket.emit(&apos;chat message&apos;, &#123;</div><div class="line">        description,</div><div class="line">        nickName,</div><div class="line">        color</div><div class="line">      &#125;)</div><div class="line">      this.description = &apos;&apos;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>前端需要用npm安装socket.io-client，不能直接使用原生的websocket语法建立连接。</p>
</li>
<li>初始化时this._config().preurl是写在配置里的一个url地址，同其他接口地址前缀一样，但是这里的url地址是http协议，也就是说一开始是把一个http协议地址传给的socket.io，然后socket.io在建立http链接之后才升级成的websocket链接。</li>
<li>on方法，用来监听来自服务端的事件，once表示监听一次，还可以取消监听</li>
<li>emit触发事件，让服务端响应。这里的loadAction就表示发送信息。</li>
</ul>
<hr>
<p>2017/11/24 更新</p>
<ul>
<li>客户端我用的vue-cli搭建的项目，整个聊天室就是在一个vue实例中，socket连接与vue实例的生命周期绑定，created的时候建立连接，beforeDestroy的时候断开连接</li>
</ul>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><ul>
<li>整体写法有点像观察者模式，服务端和客户端都是以监听/触发事件的形式完成通信，完全不同于传统的ajax交互方式，十分有趣。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/10/微信小程序-scroll-view实现锚点滑动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/10/微信小程序-scroll-view实现锚点滑动/" itemprop="url">
                  微信小程序   scroll-view实现锚点滑动
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T15:41:00+08:00">
                2017-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>最近开始做小程序，通读一遍文档再上手并不算难，但不得不说小程序里还是有一些坑。这里说一下如何实现页面锚点跳转，一个城市列表的效果示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/6383319-104bb55559f4a26b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="city.gif"></li>
<li>因为在微信小程序的环境中不能像在浏览器里设置标签，或者操作dom滚动，传统做法就行不通了，一切都得按小程序的文档来。</li>
<li>一开始我们的做法是使用<strong>boundingClientRect()方法获取每个锚点的坐标</strong>，然后再用wx.pageScrollTo()方法滑动过去。结果发现行不通，因为boundingClientRect方法返回的每个点的坐标会随着屏幕滑动而变化，<strong>最后还是选择<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/scroll-view.html" target="_blank" rel="external">scroll-view(可滚动视图区域)</a><br>组件来实现锚点效果。</strong></li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li><p>具体API就不赘述了，可以去看官方文档，这里讲几个需要注意的地方，下面是一个示意的scroll-view组件代码，上面的几个属性是必须的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;scroll-view scroll-y style=&quot;height: 200px;&quot; bindscroll=&quot;scroll&quot; scroll-into-view=&quot;&#123;&#123;toView&#125;&#125;&quot; &gt;</div></pre></td></tr></table></figure>
</li>
<li><p>scroll-into-view：这个绑定了一个属性，它的值应该是页面元素的id，设置它的值就可以跳转到ID对应的元素那里了。</p>
</li>
<li>scroll-y：添加这个属性标明是竖向滑动的，对应的scroll-x则表示横向滑动，<strong>竖向滑动时scroll-view必须设置一个固定的height</strong></li>
<li>bindscroll：监听滑动，传给他一个事件，滑动时执行该事件</li>
<li>文档上给的属性特别多，暂时只需要上述几个就可实现我们想要的效果。实现原理也很简单，内容部分，每个英文简写的view设置一个id，然后在导航list那里点击时，就把scroll-into-view的值设置成点击的那个id即可实现跳转。</li>
<li>再说一下scroll-view的高度问题，这个一定要做适配的固定高度，不然在不同屏幕大小的手机上的显示效果有差异。</li>
</ul>
<h3 id="几点优化"><a href="#几点优化" class="headerlink" title="几点优化"></a>几点优化</h3><ul>
<li><p>到这里功能基本都实现了，但后面还发现一些问题：如果要隐藏scroll-view的滚动条，需要设置css样式:::-webkit-scrollbar</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">::-webkit-scrollbar &#123;</div><div class="line">	width: 0;</div><div class="line">	height: 0;</div><div class="line">	color: transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>还有就是点了一个锚点实现了跳转，这个时候你滚动页面再点之前点的锚点，页面就不会再跳转了，这个时候就需要监听滚动事件，滚动时将scroll-into-view的值清空。</p>
</li>
</ul>
<h4 id="2017-12-05补充"><a href="#2017-12-05补充" class="headerlink" title="2017/12/05补充:"></a>2017/12/05补充:</h4><ul>
<li>scroll-view默认是无滑动动画的，需要滚动的动画效果需要在组件上设置：<strong>scroll-with-animation=’true’</strong></li>
<li>关于固定高度height的设置问题，一开始我以为这个高度和滚动元素的数目/高度有关，这个时候处理动态变化的列表就很麻烦。后面在网上看到的一个方法就是使用<strong>wx.getSystemInfo</strong>方法得到windowHeight，把这个设置为scroll-view的高度(单位为px)即可。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/javascript事件流、事件代理、target和currentTarget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/31/javascript事件流、事件代理、target和currentTarget/" itemprop="url">
                  javascript事件流、事件代理、target和currentTarget
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T09:54:00+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>这篇讲的内容是非常基础的，关于javascript中的事件相关可能不太全面，只是围绕几个知识点。可能现在mvvm框架用多了也不用多去在意dom和event，但是原生的基础知识还是需要掌握的(万一以后面试问到了呢~~)</li>
<li>Javascript与html之间的交互是通过<strong>事件</strong>来实现的。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间，可以用侦听器(或处理程序)来预定事件，以便事件发生时执行相应的代码。<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3></li>
<li><strong>事件流</strong>描述的是从页面接收到事件的顺序，一些历史发展的内容这里就不提了，直接讲”DOM2级事件”，事件流包括三个阶段：<strong>事件捕获阶段、处于目标阶段和事件冒泡阶段</strong>。最先发生的是事件捕获，然后是具体的实际目标收到事件，最后才是冒泡阶段，可以在这个阶段对事件做出响应。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/6383319-f8a239bd4cb8b4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网上找的示意图.png"></p>
<h3 id="添加事件监听"><a href="#添加事件监听" class="headerlink" title="添加事件监听"></a>添加事件监听</h3><ul>
<li><p>给元素添加事件监听的方法，可以直接在html上添加或者在javascript中指定相关的<strong>事件处理程序</strong>，但是需要注意，这种以’on’开头的事件属于’DOM0’级事件，重复定义时会覆盖掉原事件，而使用addEventListener则不会覆盖之前添加的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input id=&apos;btn&apos; value=&apos;click me&apos; onclick=&apos;alert(this.value)&apos;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>还可以使用<strong>addEventListener/removeEventListener</strong>方法，所有dom节点都包含这方法，传入三个参数:事件名、处理事件的函数、标示在捕获还是在冒泡阶段调用回调函数的布尔值。</p>
</li>
<li>addEventListener添加的事件处理函数只能用removeEventListener方法移除，传入参数与addEventListener相同，<strong>意味着addEventListener添加的匿名函数无法移除，</strong>所以在用addEventListener添加处理函数时不能使用匿名函数。环境不支持addEventListener的时候，还可以使用attachEvent/detachEvent，这里就不多做介绍了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let btn = document.getElementById(&apos;btn&apos;)</div><div class="line">let handler = function () &#123;alert(this.id)&#125;</div><div class="line">btn.addEventListener(&apos;click&apos;, handler,false)</div><div class="line">btn.removeEventListener(&apos;click&apos;, handler,false)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><ul>
<li>事件委托是什么呢？最简单来说：<strong>在父元素上添加可以处理子元素事件的事件处理函数</strong>。利用了事件冒泡，指定一个事件处理函数，来处理同一种类型的多个事件。这里顺便一起说下target和currenttarget的区别，<strong>target是触发事件的最具体的元素， currenttarget是绑定事件的元素(在函数中一般等于this)</strong>。下面具体代码示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;outter&quot;&gt;</div><div class="line">   &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var outter = document.querySelector(&apos;#outter&apos;)</div><div class="line">outter.addEventListener(&apos;click&apos;,function(e)&#123;</div><div class="line">    console.log(e.target.id)  //inner</div><div class="line">    console.log(e.currentTarget.id)  //outter</div><div class="line">    console.log(this === e.currentTarget)  //true</div><div class="line">&#125;,false);</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/23/11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/23/11/" itemprop="url">
                  使用Javascript做算法题（四）Longest Increasing Path in a Matrix
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-23T18:25:00+08:00">
                2017-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode算法题/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode算法题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>最近在LeetCode上做出了第一道难度为hard的题：) 觉得这题中规中矩挺不错的，mark一下：<a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/" target="_blank" rel="external">题目地址</a><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4></li>
<li>给出一个正整数矩阵，找出其中<strong>最长的递增路径的长度</strong>。只能上下左右移动，不能走对角线，不能环绕重复路线，不能超越边距。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">举例：</div><div class="line">输入:</div><div class="line">nums = [</div><div class="line">  [9,9,4],</div><div class="line">  [6,6,8],</div><div class="line">  [2,1,1]</div><div class="line">]</div><div class="line">返回 最长路径为4 路径为：1-&gt;2-&gt;6-&gt;9</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>基本思路分以下几个点：</li>
<li>0.依次遍历输入的矩阵(二维数组)，找出每个点作为起点时的最长递归路径长度，然后返回其中的最大值</li>
<li>1.使用dfs递归方法去遍历查找各个方向，建立一个表示移动方向的数组，每次dfs查找一个新的节点是遍历这个数组，得出最大值作为这个点为起点的最长路径，保存到dp中</li>
<li>2.新建一个二维数组作为dp数组，每次得到一个坐标点为起点的最大长度时存入dp数组相应位置，以后再查找到这个坐标点时直接返回之前保存的值避免重复运算</li>
<li>上面可能说的有点乱，大概就是dfs遍历和dp数组结合，难度其实并不算大，但是可以优化的细节还是挺多的，下面代码附有具体注释<h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[][]&#125; matrix</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var longestIncreasingPath = function(matrix) &#123;</div><div class="line">    if (!matrix || matrix.length === 0) &#123;</div><div class="line">        return 0</div><div class="line">    &#125;</div><div class="line">          </div><div class="line">    var direct = [[0, -1], [0, 1], [-1, 0], [1, 0]] // 方向数组</div><div class="line">    var max = 1 // 全局最大值</div><div class="line">    var dp = new Array() // dp二维数组，保存每个点作为起点的最大路径长度</div><div class="line">    var width = matrix[0].length</div><div class="line">    var deep = matrix.length</div><div class="line">    while (deep) &#123; </div><div class="line">        dp.push(new Array(width).fill(0)) // 每个点初始长度为0，dfs遍历到不为0的情况直接返回她的值(因为是之前已经得到了)</div><div class="line">        deep--</div><div class="line">    &#125;</div><div class="line">    deep = matrix.length</div><div class="line">    </div><div class="line">    var dfs = function (i, j) &#123;</div><div class="line">        if (dp[i][j] &gt; 0) return dp[i][j];</div><div class="line">        var mx = 1</div><div class="line">        for (var k = 0; k &lt; direct.length; k++) &#123;</div><div class="line">            var x = i + direct[k][0]</div><div class="line">            var y = j + direct[k][1]</div><div class="line">            if (x &lt; 0 || x &gt;= deep || y &lt; 0 || y &gt;=width) &#123; // 超过范围跳过</div><div class="line">                continue</div><div class="line">            &#125;</div><div class="line">            if (matrix[x][y] &lt;= matrix[i][j]) &#123;// 不是递增跳过</div><div class="line">                continue</div><div class="line">            &#125;</div><div class="line">            var len = dfs(x, y) + 1</div><div class="line">            mx = Math.max(mx, len)</div><div class="line">        &#125;</div><div class="line">        dp[i][j] = mx</div><div class="line">        return mx</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (var i = 0; i &lt; deep; i++) &#123;</div><div class="line">        for (var j = 0; j &lt; width; j++) &#123;</div><div class="line">            max = Math.max(max, dfs(i, j))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return max</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/手写JSONP-promise封装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/14/手写JSONP-promise封装/" itemprop="url">
                  手写JSONP(promise封装)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T15:41:00+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>JSONP以前研究过，最近又有点忘了，写篇本文mark一下，旨在理解记住JSONP的原理及其实现。代码实现用到es6语法，使用promise来封装JSONP方法，本地测试用的自己node搭的服务器,具体代码就不贴了。</li>
<li>一句话阐述下JSONP原理：<strong><em>动态生成一个JavaScript标签，其src由接口url、请求参数、callback函数名拼接而成，利用js标签没有跨域限制的特性实现跨域请求。</em></strong></li>
<li>有几点需要注意：1.callback函数要绑定在window对象上<br>2.服务端返回数据有特定格式要求：callback函数名+’(‘+JSON.stringify(返回数据) +’)’<br>3.不支持post，因为js标签本身就是一个get请求</li>
<li>具体代码如下，最后一段是调用函数的示例，这个函数将返回一个promise对象，获取到数据时状态为resolve<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">const jsonp = function (url, data) &#123;</div><div class="line">  return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">    // 初始化url</div><div class="line">    let dataString = url.indexOf(&apos;?&apos;) === -1 ? &apos;?&apos; : &apos;&amp;&apos;</div><div class="line">    let callbackName = `jsonpCB_$&#123;Date.now()&#125;`</div><div class="line">    url += `$&#123;dataString&#125;callback=$&#123;callbackName&#125;`</div><div class="line">    if (data) &#123;</div><div class="line">     // 有请求参数，依次添加到url</div><div class="line">      for (let k in data) &#123;</div><div class="line">        url += `&amp;$&#123;k&#125;=$&#123;data[k]&#125;`</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    let jsNode = document.createElement(&apos;script&apos;)</div><div class="line">    jsNode.src = url</div><div class="line">    // 触发callback，触发后删除js标签和绑定在window上的callback</div><div class="line">    window[callbackName] = result =&gt; &#123;</div><div class="line">      delete window[callbackName]</div><div class="line">      document.body.removeChild(jsNode)</div><div class="line">      if (result) &#123;</div><div class="line">        resolve(result)</div><div class="line">      &#125; else &#123;</div><div class="line">        reject(&apos;没有返回数据&apos;)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    // js加载异常的情况</div><div class="line">    jsNode.addEventListener(&apos;error&apos;, () =&gt; &#123;</div><div class="line">      delete window[callbackName]</div><div class="line">      document.body.removeChild(jsNode)</div><div class="line">      reject(&apos;JavaScript资源加载失败&apos;)</div><div class="line">    &#125;, false)</div><div class="line">    // 添加js节点到document上时，开始请求</div><div class="line">    document.body.appendChild(jsNode)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line">jsonp(&apos;http://192.168.0.103:8081/jsonp&apos;, &#123;a: 1, b: &apos;heiheihei&apos;&#125;)</div><div class="line">  .then(result =&gt; &#123; console.log(result) &#125;)</div><div class="line">  .catch(err =&gt; &#123; console.error(err) &#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>个人感觉JSONP用的情况还是比较少吧，如果已经是需要服务端配合来进行跨域的情况，为什么不直接用CORS呢</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/11/使用eslint检查JS代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/11/使用eslint检查JS代码/" itemprop="url">
                  使用eslint检查JS代码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-11T16:13:00+08:00">
                2017-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>代码规范一直是开发过程中比较重要的一环，包括命名规范、统一缩进等等，规范整洁的代码可读性高，也便于后期代码维护以及其他开发人员快速熟悉；本篇就讲一下eslint的具体用法。</li>
</ul>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>eslint早在2013年就有了，而我个人第一次接触还是在使用vue-cli搭建项目的时候，默认配置的eslint会根据规则直接报错，刚开始用的时候满屏报错、特别酸爽~~ 但只要习惯就好，使用eslint检查代码会使你的js文件更加健壮好看。</li>
</ul>
<h4 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h4><ul>
<li>首先安装eslint，直接 <strong>npm install eslint</strong>即可，注意如果你是全局安装的eslint，后面一些eslint相关依赖包也要全局安装。</li>
<li><p>然后输入 <strong>eslint init</strong> 开始初始化一个配置文件，过程中会给你很多选项，比如是否使用es6、是否使用jsx语法、配置文件的文件格式等等。我选择的生成js配置文件，所有选项都选好后，生成一个<strong>.eslintrc.js</strong>配置文件内容大概长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">    &quot;env&quot;: &#123;</div><div class="line">        &quot;browser&quot;: true,</div><div class="line">        &quot;es6&quot;: true</div><div class="line">    &#125;,</div><div class="line">    &quot;extends&quot;: &quot;eslint:recommended&quot;,</div><div class="line">    &quot;parserOptions&quot;: &#123;</div><div class="line">        &quot;sourceType&quot;: &quot;module&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;rules&quot;: &#123;</div><div class="line">        &quot;indent&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;tab&quot;</div><div class="line">        ],</div><div class="line">        &quot;linebreak-style&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;windows&quot;</div><div class="line">        ],</div><div class="line">        &quot;quotes&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;double&quot;</div><div class="line">        ],</div><div class="line">        &quot;semi&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;never&quot;</div><div class="line">        ],</div><div class="line">        &quot;no-console&quot;: 0 </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>其中最重要的就是<strong>rules</strong>里面配置的规则，eslint会根据这里是配置的rule规则对代码进行检验，键值分别对应规则名和状态，比如”no-console“是规则名，后面对应的0表示不执行这条规则。extends表示继承自哪个共享的配置文件，env表示检查代码时所属的环境。</p>
</li>
<li>具体状态码规则是这样：  <strong>0</strong>或者“<strong>off</strong>”表示关闭规则； <strong>1</strong>或者<strong>warn</strong>表示开启规则，使用警告级别的错误； <strong>2</strong>或者<strong>error</strong>表示开启规则，使用错误级别的错误：error (当被触发的时候，程序会报错)</li>
<li>配置完成后，在当前目录新建一个index.js文件，随便输入几行代码，<strong>然后在命令行输入eslint index.js</strong>。就会对js文件进行代码检查，如果代码报错，命令行会提示你多少行触发了哪条规则的错误，你就可以对代码进行改正，或者修改配置文件中的rule规则。</li>
<li>配置eslint的方法还有其他的，比如写在package.json中：新增一个eslintConfig，将上述配置文件的内容放在下面。但我个人还是喜欢用单独的配置文件，来控制eslint。<h4 id="集成到webpack"><a href="#集成到webpack" class="headerlink" title="集成到webpack"></a>集成到webpack</h4></li>
<li>接下来介绍一下如何把eslint集成到webpack中。首先确保webpack已经安装好，然后依次安装eslint-loader、eslint-config-standard、eslint-plugin-html、eslint-plugin-promise、eslint-plugin-standard、eslint-friendly-formatter。注意如果eslint是全局安装的，这些依赖包也需要全局安装，否则报错找不到对应的包。</li>
<li><p><strong>然后新建一个webpack的配置文件webpack.config.js</strong>，我这里只是做尽量最少的配置，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    entry: &#123;</div><div class="line">        index: &quot;./src/index.js&quot;,</div><div class="line">    &#125;,</div><div class="line">    output: &#123;</div><div class="line">        path: __dirname + &quot;/dist/&quot;,</div><div class="line">        filename: &quot;[name].js&quot;</div><div class="line">    &#125;,</div><div class="line">    resolve: &#123;</div><div class="line">        extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;]</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">         rules: [</div><div class="line">                &#123;</div><div class="line">                    test: /\.js$/,</div><div class="line">                    exclude: /node_modules/,</div><div class="line">                    loaders: [</div><div class="line">                        &apos;eslint-loader&apos;</div><div class="line">                    ]</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    test: /\.vue|\.js$/,</div><div class="line">                    enforce: &apos;pre&apos;,  // 在babel-loader对源码进行编译前进行lint的检查</div><div class="line">                    include: /src/,  // src文件夹下的文件需要被lint</div><div class="line">                    use: [&#123;</div><div class="line">                        loader: &apos;eslint-loader&apos;,</div><div class="line">                        options: &#123;</div><div class="line">                            formatter: require(&apos;eslint-friendly-formatter&apos;)   // 编译后错误报告格式</div><div class="line">                        &#125;</div><div class="line">                    &#125;]</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这时候文件目录结构如下图<br><img src="http://upload-images.jianshu.io/upload_images/6383319-f6ea3f19ed2c3380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件结构"></p>
</li>
<li>这时在src文件夹下新建index.js文件，命令行输入webpack进行代码打包的过程会使用eslint进行检查，如果无误就在dist/js文件夹下生产打包后的代码，如果检查报错则在命令行中打印出错误位置和触犯的规则。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/27/从几个关键词来理解http缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/27/从几个关键词来理解http缓存/" itemprop="url">
                  从几个关键词来理解http缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-27T15:19:00+08:00">
                2017-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>我对于http缓存的认知总是停留在略知一二的状态，毕竟实际工作中用的比较少-_-||<br>但作为一个严谨的程序员，这仍是必备的一个知识技能。想了想还是写篇博客来总结下相关的一些知识，从一些关键词来理解http的缓存<h5 id="强缓存与协商缓存"><a href="#强缓存与协商缓存" class="headerlink" title="强缓存与协商缓存"></a>强缓存与协商缓存</h5></li>
<li>首先需要知道的是读取http缓存的方式是有两种的：<strong>强缓存(本地缓存)</strong>和<strong>协商缓存(对比缓存)</strong>，下面讲一下这两种工作方式的区别和特点。</li>
<li><p><strong>强缓存</strong>： 客户端发送请求时，首先访问浏览器的缓存数据库，若得知缓存存在且有效，则直接读取缓存内容返回给客户端，此时返回状态码为<strong>200（from cache）</strong>;而如果发现缓存失效了或不存在，则会去请求<strong>服务器</strong>得到相关内容信息，此时返回状态码为200，操作示意图如下<br><img src="http://upload-images.jianshu.io/upload_images/6383319-5018186b2e518efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="强缓存.png"></p>
</li>
<li><p><strong>协商缓存</strong>： 客户端发送请求时，如果是第一次请求资源，则直接访问服务器，服务器将相关内容和缓存标示返回给客户端；如果是再次请求资源，<strong>客户端将第一次访问时服务器返回的缓存标示发送给服务器，服务器来判断缓存是否可用，</strong>如果缓存可用则告诉客户端可以继续使用缓存的内容，此时<strong>返回码为304</strong>，操作示意图如下<br><img src="http://upload-images.jianshu.io/upload_images/6383319-e872781570ae4356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协商缓存.png"></p>
</li>
<li>综上可以直观的看出两种方式的区别，最明显的是<strong>缓存命中时返回码不同</strong>，还有对比缓存的方式：<strong>每一次都会去访问服务器，无论缓存命中与否</strong>。那么对于浏览器和服务器是如何区分强缓存还是对比缓存，以及如何判断缓存是否有效呢，这就需要那些放在<strong>http报文header中</strong>的相关字段了，接下来依次讲解他们。ps：两种缓存方式是可以同时存在的，同时存在时，强缓存的优先级更高。<h4 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h4></li>
<li>用于定义强缓存的header字段，这是http1.0时的规范，它的值为一个GMT格式时间字符串，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。但是已经过时了，基本可以忽略。<h4 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h4></li>
<li>http1.1版本出现的header信息，用来定义缓存信息。包括了好几个字段，其中最重要的就是<strong>max-age</strong>：用于表示缓存多少秒后失效。比如max-age = 31536000，表示缓存时间为365天，从第一次请求后的365天内再次请求都会去读取缓存。这个也是用来控制强制缓存的header字段。<h5 id="协商缓存相关的header字段"><a href="#协商缓存相关的header字段" class="headerlink" title="协商缓存相关的header字段"></a>协商缓存相关的header字段</h5></li>
<li>协商缓存的方式总是会去访问服务器来确定缓存是否可用的，所以需要通过某种标识来进行通信，主要包括下面两组header字段(他们都是要成对出现)，即第一次请求的响应头带上某个字段（<strong>Last-Modified/Etag</strong>），则后续请求头则会带上对应的请求字段（<strong>If-Modified-Since/If-None-Match</strong>），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。<h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified  /  If-Modified-Since"></a>Last-Modified  /  If-Modified-Since</h5></li>
<li>这组值都是时间字符串。具体行为如下：第一次请求时服务器返回的response headers带上<strong>Last-Modified字段表示资源最后一次修改的时间</strong>，再次请求时浏览器的request headers带上<strong>If-Modified-Since</strong>这个值和第一次访问返回的Last-Modified值是一样的，然后给到服务器再进行判断缓存是否过期<h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h5></li>
<li>这组字段的值是服务器生成的唯一标示字符串，用法和上面的Last-Modified/If-Modified-Since类似，第一次访问时服务器会返回一个Etag，再次访问浏览器就会带上If-None-Match其值为第一次返回的Etag，给到服务器，服务器进行判断缓存是否可用。ps: Etag和Last-Modified同时使用时，服务器会<strong>优先判断Etag</strong>，好像是etag的精准级别更高。<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4></li>
<li>大概就这么多了，都是以最基本的概念为主，参考了一些网上的资料，如果有机会的话再深入地研究下~~~<br>参考：<a href="http://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="external">彻底弄懂HTTP缓存机制及原理</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/apply与call性能分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/15/apply与call性能分析/" itemprop="url">
                  apply与call性能分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-15T13:53:21+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="apply-call-基本概念"><a href="#apply-call-基本概念" class="headerlink" title="apply call 基本概念"></a>apply call 基本概念</h4><ul>
<li>稍有一些javascript基础的人应该对这两个函数都不会陌生，这里简单过一下基本概念。这两个方法一般都是用来调用一个函数时改变其内部this指向，换句话说：<strong>劫持一个对象的方法，继承另外一个对象的属性并调用</strong>。语法上两者唯一的不同就是传参形式：</li>
<li>Function.apply(obj,args)方法能接收两个参数：<br>obj：这个对象将代替Function类里this对象<br>args：这个是数组，它将作为参数传给Function（args–&gt;arguments）</li>
<li>Function.call(obj,[param1[,param2[,…[,paramN]]]]) call方法接收多个参数，比如你调用函数时传入三个参数就得这样写： fun.call(obj,arg1,arg2,arg3)，在不确定传入参数有多少个时用call来执行就很麻烦。</li>
<li>以前我的理解就是这两个函数区别就是上面这些了，最近我才知道，他们执行起来的速度差异还挺大的。<h4 id="apply与call性能对比"><a href="#apply与call性能对比" class="headerlink" title="apply与call性能对比"></a>apply与call性能对比</h4></li>
<li>这里有个网站：<a href="">https://jsperf.com/call-apply-segu</a>，执行测试用例，得出的结果是以Ops/sec（每秒操作数）为单位。根据操作系统和浏览器内核版本等不同，最后的结果也不一样，但总体来说可以得到的结论是：<strong>call方法永远比apply方法执行速度要快</strong>。下面贴两张运算结果的截图：<br><img src="http://upload-images.jianshu.io/upload_images/6383319-cf3c9edc35aafe40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Safari浏览器MacOs系统"></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/6383319-94db063de6db0239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Chrome浏览器window系统"></p>
<ul>
<li>初步结论是速度和<strong>浏览器内核</strong>有关，但apply肯定是要比call运行速度更慢的，在chrome上甚至可以看见，结果居然差了一个位数。</li>
<li><p>所以在一些框架中，<strong>为了追求更快的执行速度就是舍弃掉apply方法或者用call来模拟apply方法。</strong>比如我们现在框架上就是这样做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">switch (args.length) &#123;</div><div class="line">        case 0:</div><div class="line">          g = gen.call(ctx);</div><div class="line">          break;</div><div class="line">        case 1:</div><div class="line">          g = gen.call(ctx, args[0]);</div><div class="line">          break;</div><div class="line">        case 2:</div><div class="line">          g = gen.call(ctx, args[0], args[1]);</div><div class="line">          break;</div><div class="line">        default:</div><div class="line">          g = gen.apply(ctx, args);</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这样根据参数的长度，switch/case判断来执行不同的call语句，实在没有case的时候再执行apply方法。虽然这样写看起来代码很累赘，直接用apply就只需要一句话的事，但是如果要追求极致性能还是需要这样做（在angular2的源码中也有类似的部分，其中写了20个case判断参数长度）。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4></li>
<li>那是不是说以后都不要用apply方法了呢？当然不是啦~在项目中某些文件，比如启动程序时执行的，用到了apply方法，但理论上这里只执行一次，那这个时候换成call 方法带来的性能提升基本也可以忽略不计了。</li>
<li><p>ES7中有一个关于绑定this的提案：并排的两个冒号（::）组成的函数绑定运算符，它的左边是一个对象，右边是一个函数，通过这个运算符将左边对象作为this绑定到右边函数上面去。这种写法就不用纠结是用call还是apply了，但现在浏览器都不支持，需要用babel转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo::bar(...arguments);</div><div class="line">// 等同于：</div><div class="line">bar.apply(foo, arguments);</div></pre></td></tr></table></figure>
</li>
<li><p>在不确定参数的情况下，如果不考虑性能，代码层面用apply来写会简洁很多。不过你能确认参数长度的时候，最好都用call方法而不用apply。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="TokenYangForever" />
          <p class="site-author-name" itemprop="name">TokenYangForever</p>
           
              <p class="site-description motion-element" itemprop="description">放点随笔文章</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TokenYangForever</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
