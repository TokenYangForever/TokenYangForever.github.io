<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="放点随笔文章">
<meta property="og:type" content="website">
<meta property="og:title" content="唐洋洋的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="唐洋洋的个人博客">
<meta property="og:description" content="放点随笔文章">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="唐洋洋的个人博客">
<meta name="twitter:description" content="放点随笔文章">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 唐洋洋的个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">唐洋洋的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">\(^o^)/~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/13/用react-native实现一个数独游戏-总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/13/用react-native实现一个数独游戏-总结/" itemprop="url">
                  用react-native实现一个数独游戏(总结)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-13T15:41:00+08:00">
                2017-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/react-native/" itemprop="url" rel="index">
                    <span itemprop="name">react-native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>最近用react-native做了一个数独游戏的app，到今天基本功能已经全都完成并打包在真机上测试了，这里总结一下开发过程中的一些问题和实现的思路。<br><img src="http://upload-images.jianshu.io/upload_images/6383319-c4e4dbb2eaf0a4ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<h4 id="环境和平台选择"><a href="#环境和平台选择" class="headerlink" title="环境和平台选择"></a>环境和平台选择</h4><ul>
<li>项目上读取的接口是我自己服务器上部署的，用node实现的接口，链接mysql数据库，数独题目就是从这里读取得到。因为服务器上只有http接口，所以app开发时也就选择的android版本。<h4 id="功能及实现"><a href="#功能及实现" class="headerlink" title="功能及实现"></a>功能及实现</h4></li>
<li>因为只是一个简单的demo，做的功能也比较简单：新游戏/继续游戏/选择难度。页面有三个：首页/棋盘页面/关于。</li>
<li><p>页面导航使用的react-navigation，从首页进入棋盘页面时，会传参数过去表示是否是新游戏和游戏难度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.props.navigation.navigate(&apos;Main&apos;, &#123;difficulty: text, newgame: true&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>数独棋盘的生成，是从数据库得到数据，然后再渲染出来。一开始我是打算随机生成棋盘的，但是发现生成的棋盘可能会出现多解的情况，最后想想还是算了，在网上找了几个数独题目存在数据库里。</p>
</li>
<li><p>触发提交按钮后，会对棋盘进行验证，有空白没有填完则返回，然后再依次判断各个点是否满足数独条件，判断方法可参考LeetCode上的一道题：<a href="https://leetcode.com/problems/valid-sudoku/description/" target="_blank" rel="external">Valid Sudoku</a>，下面还是贴下判断结果的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">let arr = this.state.arr</div><div class="line">let dp = &#123;&#125;</div><div class="line">let index = 0</div><div class="line">for (let a = 0; a &lt; 3; a++) &#123;</div><div class="line">  for (let b = 0; b &lt; 3; b++) &#123;</div><div class="line">    dp[`area$&#123;a&#125;$&#123;b&#125;`] = new Map()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">for (let i = 0; i &lt; 9; i++) &#123;</div><div class="line">  dp[`x$&#123;i&#125;`] = new Map()</div><div class="line">  dp[`y$&#123;i&#125;`] = new Map()</div><div class="line">&#125;</div><div class="line">for (let i = 0; i &lt; 9; i++) &#123;</div><div class="line">  for (let j = 0; j &lt; 9; j++) &#123;</div><div class="line">    let temp = arr[index]</div><div class="line">    if (temp !== &apos;&apos;) &#123;</div><div class="line">      let xIndex = &apos;x&apos; + j</div><div class="line">      let yIndex = &apos;y&apos; + i</div><div class="line">      let areaIndex = &apos;area&apos; + Math.floor(j/3) + Math.floor(i/3)</div><div class="line">      if (dp[xIndex].has(temp) || dp[yIndex].has(temp) || dp[areaIndex].has(temp)) &#123;</div><div class="line">        return [false, &apos;有空格填错了哦~&apos;, index]</div><div class="line">      &#125; else &#123;</div><div class="line">        dp[xIndex].set(temp, true)</div><div class="line">        dp[yIndex].set(temp, true)</div><div class="line">        dp[areaIndex].set(temp, true)</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      return [false, &apos;还有空格没填完哦~&apos;]</div><div class="line">    &#125;</div><div class="line">    index++</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">return [true]</div></pre></td></tr></table></figure>
</li>
<li><p>数据存储还是使用的react-native提供的AsyncStorage，并对其进行一层包装。未完成的棋局缓存起来，继续游戏的时候再调用。</p>
</li>
<li>基本上就是这些了，以后有机会再补充。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/react-native-react-开发中遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/06/react-native-react-开发中遇到的问题/" itemprop="url">
                  react-native/react 开发中遇到的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T16:26:00+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/react-native/" itemprop="url" rel="index">
                    <span itemprop="name">react-native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>最近对react-native产生些兴趣，准备学一学，写写demo练练手，然而之前对react页不是很熟悉，所以一边学一边写code，一边看react-native的文档一边撘环境。中途还是遇到很多问题，写篇文章mark下。<h4 id="react-native搭建开发环境时遇到的问题"><a href="#react-native搭建开发环境时遇到的问题" class="headerlink" title="react-native搭建开发环境时遇到的问题"></a>react-native搭建开发环境时遇到的问题</h4></li>
<li>搭建Android开发环境：</li>
</ul>
<ol>
<li>java版本不能装9.0+的，路径格式不同，Android-studio无法识别路径。</li>
<li>Android SDK 要装25.0+的，不然会提示版本过低无法继续，然而教程(甚至是fb官网上)还是写的装23.0</li>
<li>模拟器，先在Android-studio打开Android模拟器之后，再在命令行执行react-native run-android命令</li>
<li>执行react-native run-*命令时，启动的packager server需要使用8081端口，确保这个端口没有占用！<h4 id="RN中写样式"><a href="#RN中写样式" class="headerlink" title="RN中写样式"></a>RN中写样式</h4></li>
</ol>
<ul>
<li>本来平时我css就写得少，RN中这种变种的css写起来更蛋疼。。。。<a href="https://github.com/doyoe/react-native-stylesheet-guide" target="_blank" rel="external">React-Native 样式指南</a></li>
<li>RN中的样式相当于css的缩减版，命名方式要用驼峰法，然后大部分属性都能和css中对应。布局：也有相对定位和绝对定位，也支持flex。<strong>官方推荐flex</strong>，可以解决大多数的布局情况。</li>
<li>建议使用StyleSheet.create()生成样式的类名，也可以直接在组件上写”内联”样式。</li>
<li>RN中元素的<strong>宽高是没有单位的</strong>，直接用数字表示即可，也可以用flex来实现弹性宽高。</li>
<li>另外就是要注意，不同的组件可以设置的样式是不同的，比如遇到无法设置宽高的组件就只能在它外层包个view，然后设置这个view的宽高。<h4 id="RN中调试"><a href="#RN中调试" class="headerlink" title="RN中调试"></a>RN中调试</h4></li>
<li>打开调试菜单：iOS模拟器中：Command⌘ + D 快捷键；Android模拟器对应的则是Command⌘ + M</li>
<li>Enable Live Reload：开启自动刷新</li>
<li>Enable Hot Reload：开启热加载</li>
<li>访问控制台日志:在终端中运行：react-native log-ios或者log-android</li>
<li>在开发者菜单中选择”Debug JS Remotely”选项，即可以开始在Chrome中调试JavaScript代码。点击这个选项的同时会自动打开调试页面 <a href="http://localhost:8081/debugger-ui" target="_blank" rel="external">http://localhost:8081/debugger-ui</a>.</li>
<li>注:Chrome中并不能直接看到App的用户界面，而只能提供console的输出，以及在sources项中断点调试js脚本。</li>
</ul>
<h4 id="RN中的网络通信"><a href="#RN中的网络通信" class="headerlink" title="RN中的网络通信"></a>RN中的网络通信</h4><ul>
<li>文档上介绍的是使用fetch，我也专门去了解了一下下，算是ajax的进化版，结合了一些html5的新特性。RN中也支持websocket。</li>
<li>默认情况下，iOS会阻止所有非https的请求。如果你请求的接口是http协议，那么首先需要添加一个App Transport Security的例外，详细可参考<a href="https://segmentfault.com/a/1190000002933776" target="_blank" rel="external">这篇帖子</a>。</li>
</ul>
<h4 id="RN中的数据存储"><a href="#RN中的数据存储" class="headerlink" title="RN中的数据存储"></a>RN中的数据存储</h4><ul>
<li>在浏览器环境，我们可以使用cookie、localstorage或者sessionstorage来实现数据缓存，在RN中则不能使用以上的三种方式。</li>
<li><a href="http://reactnative.cn/docs/0.50/asyncstorage.html#content" target="_blank" rel="external">AsyncStorage</a>是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的。它用来代替LocalStorage。</li>
</ul>
<h4 id="react相关"><a href="#react相关" class="headerlink" title="react相关"></a>react相关</h4><ul>
<li><p>react事件需要手动绑定this，或者使用箭头函数来声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">this.handleClick = this.handleClick.bind(this);</div><div class="line">// 或者</div><div class="line">onClick=&#123;(e) =&gt; this.handleClick(e)&#125;</div><div class="line">handleClick = () =&gt; &#123;...&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>react的组件必须以大写字母命名: 小写字母的标签会被认为是html的标签而不会被编译。一般表达式声明react的组件也要用大写字母开头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const SpecificStory = components[props.storyType];</div><div class="line">  return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/Fetch初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/22/Fetch初探/" itemprop="url">
                  Fetch初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T13:34:00+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Html/" itemprop="url" rel="index">
                    <span itemprop="name">Html</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>fetch这个东西，之前也看到过有人介绍，但毕竟还是实验性阶段的东西，最近在看react-native的文档，讲到网络的地方，文档上是推荐地使用fetch，想必框架本身也对其有所封装。这里就先自己学习一下fetch相关的基础知识。<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="external">Fetch</a> 是一个现代的概念, 等同于<a href="https://developer.mozilla.org/enUS/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a>。它提供了许多与XMLHttpRequest相同的功能，但被设计成更具可扩展性和高效性。下图显示了fetch在浏览器中的支持情况，可以看到在主流浏览器的支持性还是不错的，实在不支持fetch的浏览器(比如IE)上面也可以使用相应的polyfill库。<br><img src="http://upload-images.jianshu.io/upload_images/6383319-9575a5a9c01ac1fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fetch在浏览器中的支持情况.png"><h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4></li>
<li><p>使用fetch首先需要具备promise的相关知识，还涉及到一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response" target="_blank" rel="external">Response</a>对象，直接来看下代码，这是一段调用json格式数据接口的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fetch(&apos;http://101.200.35.148:8081/todo/getTodo&apos;)</div><div class="line">  .then(response =&gt; &#123;</div><div class="line">    response.json().then(</div><div class="line">        // 这里的result就是最终的接口数据了</div><div class="line">        result =&gt; &#123;</div><div class="line">          console.log(result)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>在支持fetch的浏览器中，fetch方法是global的可以直接调用。上述代码是一个get请求(默认方法是get)，fetch执行后会返回一个promise对象，这个promise对象resolve之后得到一个response对象(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response" target="_blank" rel="external">Response</a>的实例)。</p>
</li>
<li><strong>response对象</strong>相当于整个流程中的一个中间状态，它自带一个json方法用于解析从接口得到的数据，还有一个属性bodyUsed标识是否已经被解析，response.json()执行后也是返回一个promise对象，正确执行后then()这里得到的result对象就是最终的接口数据了。执行完json方法后，response对象的bodyUsed会变成true，表示这个response对象是已经被读取过了的，这时候如果再次调用response的json方法就会报错。<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4></li>
<li><p>接着来看下fetch如何处理post请求，fetch方法可以接收第二个参数来设置发送请求的方法、header、请求参数等，下面是一个post请求的示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fetch(&quot;/post/api/&quot;, &#123;</div><div class="line">    method: &quot;POST&quot;,</div><div class="line">    body: &quot;A=参数A&amp;B=参数B&quot;,</div><div class="line">    headers: new Headers()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>其中body就表示请求参数，可根据具体情况自行调整数据结构;method设定请求方法，默认为get大小写皆可，headers用于设置发送请求的header。fetch在请求post的时候如果没有成功，则会尝试重新以get方法发送请求。</p>
<h4 id="使用async-await"><a href="#使用async-await" class="headerlink" title="使用async/await"></a>使用async/await</h4></li>
<li>因为多了一层response，这里的promise回调代码结构就略显复杂，所以用fetch时使用async/await代码就会精简许多，可读性也会大大提高，比如下面这样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">async componentDidMount () &#123;</div><div class="line">  try &#123;</div><div class="line">    let res = await fetch(&apos;http://101.200.35.148:8081/todo/getTodo&apos;)</div><div class="line">    let &#123;result&#125; = await res.json()</div><div class="line">    this.setState(&#123;</div><div class="line">      result</div><div class="line">    &#125;)</div><div class="line">  &#125; catch(e) &#123;</div><div class="line">    console.log(e)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h4><ul>
<li><p>fetch除了用于post/get调取接口以外还可以请求图片，下面是一段请求图片，然后将图片显示在dom上的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var myImage = document.querySelector(&apos;img&apos;);</div><div class="line"></div><div class="line">fetch(&apos;flowers.jpg&apos;)</div><div class="line">.then(function(response) &#123;</div><div class="line">  return response.blob();</div><div class="line">&#125;)</div><div class="line">.then(function(myBlob) &#123;</div><div class="line">  var objectURL = URL.createObjectURL(myBlob);</div><div class="line">  myImage.src = objectURL;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>可以看到代码第一步还是获取response对象，之后调用了response.blob()来得到一个blob对象，这里又涉及到了另一个新特性<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="external">Blob</a>，继续调用URL.createObjectURL可将blob对象转换为一个临时链接供img标签使用。Blob相关暂不多做介绍，这里只是为了说明一下fetch还有这一种用法。</p>
</li>
<li>参考： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/17/JavaScript中的-抽象语法树-AST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/17/JavaScript中的-抽象语法树-AST/" itemprop="url">
                  JavaScript中的 抽象语法树 AST
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-17T17:40:00+08:00">
                2017-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><ul>
<li>抽象语法树（Abstract Syntax Tree）也称为AST语法树，指的是源代码语法所对应的树状结构。也就是说，一种编程语言的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。 <img src="http://upload-images.jianshu.io/upload_images/6383319-b70c4cc018199852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图.png"></li>
<li>程序代码本身可以被映射成为一棵语法树，而通过操纵语法树，我们能够精准的获得程序代码中的每一个精确的节点。例如声明语句，赋值语句，而这是用正则表达式所不能准确体现的地方。<a href="http://esprima.org/demo/parse.html#" target="_blank" rel="external">esprima</a>提供了一个在线解析JavaScript代码的地址，可以清楚地观察到js代码被转化为JSON格式，由一个个具体的符号组成</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>抽象语法树的作用非常的多，比如编译器、IDE、压缩优化代码等。在JavaScript中，虽然我们并不会常常与AST直接打交道，但却也会经常的涉及到它。例如使用UglifyJS来压缩代码，实际这背后就是在对JavaScript的抽象语法树进行操作。<br><img src="http://upload-images.jianshu.io/upload_images/6383319-09faa2604367b873.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图2.png"></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/15/socket-io-实现在线聊天室/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/15/socket-io-实现在线聊天室/" itemprop="url">
                  socket.io 实现在线聊天室
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T10:20:00+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/6383319-ba462293ba9834bb.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图.gif"></p>
<ul>
<li><h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4></li>
<li>WebSocket协议是<strong>基于TCP</strong>的一种新的网络协议。它实现了<strong>浏览器与服务器全双工(full-duplex)通信</strong>——允许服务器主动发送信息给客户端。websocket链接建立后，服务端和客户端可通过连接通道自由通信。wx协议也有类似于https的wss协议，也是多了一层TLS协议。</li>
<li>websocket具体详细的内容就不多做介绍了，因为我这次使用的socket.io框架，写起来的语法和原生websocket语法还是有很大差别的。<h4 id="Socket-io简介"><a href="#Socket-io简介" class="headerlink" title="Socket.io简介"></a>Socket.io简介</h4></li>
<li>socket.io可以看做是一个对websocket进行了封装的一个框架，目的也是为了实现客户端和服务端的全双工通信。socket.io的底层是engine.io，engine.io在不支持websocket的浏览器中，会使用ajax的长轮询实现效果。</li>
<li>具体过程，浏览器和服务端首先建立xhr链接，第一次握手后，服务端返回浏览器一个upgrades字段，告诉前端可以升级为websocket协议，socket.io客户端的框架会进行环境监测支持websocket的话，就会将xhr链接升级为websocket。建立起一个websocket连接后，服务器和浏览器之间还会定期的ping-pong来确定网络链接是否正常。<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3></li>
<li>再来看下具体实现的代码如何写，<a href="https://socket.io/" target="_blank" rel="external">socket.io官网</a>上面的文档和教程还是挺详细的，而我们要实现这个多人聊天室也只需要其中一些比较基本的api即可。<h4 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h4></li>
<li><p>服务端我用的node，直接用Npm安装socket.io，可以用socket.io直接搭建服务器，也可以在原有的express/koa上部署，我之前用的express，这里就是将socket.io添加到原有的express服务器上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">let app = new (require(&apos;express&apos;))()</div><div class="line">const server = app.listen(8081, () =&gt; &#123;</div><div class="line">  let peopleCounts = 0</div><div class="line">  let io = require(&apos;socket.io&apos;)(server)</div><div class="line">  io.on(&apos;connection&apos;, function (client) &#123;</div><div class="line">    // 这里的作用域是局部的，针对一个窗口发起的ws链接</div><div class="line">    ++peopleCounts</div><div class="line">    let uname = &apos;&apos;</div><div class="line">    let uColor = require(&apos;./methods/util&apos;).getColor()</div><div class="line"></div><div class="line">    client.on(&apos;disconnect&apos;, function (e) &#123;</div><div class="line">      --peopleCounts</div><div class="line">      io.emit(&apos;sys message&apos;, &#123;</div><div class="line">        data: `系统消息: &quot;$&#123;uname&#125;&quot;离开聊天室`,</div><div class="line">        counts: peopleCounts</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    require(&apos;./methods/getNickName&apos;)()</div><div class="line">      .then(name =&gt; &#123;</div><div class="line">        uname = name</div><div class="line">        io.emit(&apos;initUser&apos;, &#123;</div><div class="line">          name,</div><div class="line">          color: uColor</div><div class="line">        &#125;)</div><div class="line">        io.emit(&apos;sys message&apos;, &#123;</div><div class="line">          data: `系统消息: &quot;$&#123;name&#125;&quot;进入聊天室`,</div><div class="line">          counts: peopleCounts</div><div class="line">        &#125;)</div><div class="line">      &#125;)</div><div class="line">      .catch(e =&gt; &#123; console.log(e) &#125;)</div><div class="line"></div><div class="line">    client.on(&apos;chat message&apos;, function (data) &#123;</div><div class="line">      io.emit(&apos;message from server&apos;, data)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">  console.log(&apos;Example app listening on port 8081!&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>在express服务器搭建成功的回调函数里绑定socket.io，这里的io变量就是表示socket.io的服务端。</p>
</li>
<li>.on方法监听事件，这些事件来自建立websocket连接时或者浏览器端主动触发。</li>
<li><p>.emit触发事件，前端可以监听这些事件。比如一个客户端连接到服务端时，服务端会生成一个随机昵称(getNickName方法非必要)，然后返回给客户端。</p>
<h4 id="客户端部署"><a href="#客户端部署" class="headerlink" title="客户端部署"></a>客户端部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">import io from &apos;socket.io-client&apos;</div><div class="line">export default &#123;</div><div class="line">  name: &apos;cheatRoom&apos;,</div><div class="line">  data () &#123;</div><div class="line">    return &#123;</div><div class="line">      description: &apos;&apos;,</div><div class="line">      nickName: &apos;&apos;,</div><div class="line">      counts: 1,</div><div class="line">      msg: [],</div><div class="line">      color: &apos;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  created () &#123;</div><div class="line">    window.vm = this</div><div class="line">    this.initSocket()</div><div class="line">  &#125;,</div><div class="line">  beforeDestroy () &#123;</div><div class="line">    // socket链接与vue生命周期绑定，vue销毁时手动断开socket链接</div><div class="line">    this.socket.close()</div><div class="line">  &#125;</div><div class="line">  methods: &#123;</div><div class="line">    initSocket () &#123;</div><div class="line">      const socket = io(this._config().preurl)</div><div class="line">      socket.on(&apos;connect&apos;, () =&gt; &#123;</div><div class="line">        this.socket = socket</div><div class="line">      &#125;)</div><div class="line">      // 这里api语法类似于jQuery,支持once监听一次,off取消监听</div><div class="line">      // [https://socket.io/docs/client-api/#socket-on-eventname-callback](https://socket.io/docs/client-api/#socket-on-eventname-callback)</div><div class="line">      socket.once(&apos;initUser&apos;, (&#123;name, color&#125;) =&gt; &#123;</div><div class="line">        this.nickName = name</div><div class="line">        this.color = color</div><div class="line">      &#125;)</div><div class="line">      socket.on(&apos;sys message&apos;, (&#123; data, counts &#125;) =&gt; &#123;</div><div class="line">        this.counts = counts</div><div class="line">        this.msg.push(&#123;</div><div class="line">          description: data,</div><div class="line">          sys: true</div><div class="line">        &#125;)</div><div class="line">      &#125;)</div><div class="line">      socket.on(&apos;message from server&apos;, (item) =&gt; &#123;</div><div class="line">        item.sys = false</div><div class="line">        this.msg.push(item)</div><div class="line">      &#125;)</div><div class="line">    &#125;,</div><div class="line">    loadAction () &#123;</div><div class="line">      let &#123; description, nickName, color &#125; = this</div><div class="line">      if (this.description.length === 0) &#123;</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line">      this.socket.emit(&apos;chat message&apos;, &#123;</div><div class="line">        description,</div><div class="line">        nickName,</div><div class="line">        color</div><div class="line">      &#125;)</div><div class="line">      this.description = &apos;&apos;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>前端需要用npm安装socket.io-client，不能直接使用原生的websocket语法建立连接。</p>
</li>
<li>初始化时this._config().preurl是写在配置里的一个url地址，同其他接口地址前缀一样，但是这里的url地址是http协议，也就是说一开始是把一个http协议地址传给的socket.io，然后socket.io在建立http链接之后才升级成的websocket链接。</li>
<li>on方法，用来监听来自服务端的事件，once表示监听一次，还可以取消监听</li>
<li>emit触发事件，让服务端响应。这里的loadAction就表示发送信息。</li>
</ul>
<hr>
<p>2017/11/24 更新</p>
<ul>
<li>客户端我用的vue-cli搭建的项目，整个聊天室就是在一个vue实例中，socket连接与vue实例的生命周期绑定，created的时候建立连接，beforeDestroy的时候断开连接</li>
</ul>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><ul>
<li>整体写法有点像观察者模式，服务端和客户端都是以监听/触发事件的形式完成通信，完全不同于传统的ajax交互方式，十分有趣。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/10/微信小程序-scroll-view实现锚点滑动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/10/微信小程序-scroll-view实现锚点滑动/" itemprop="url">
                  微信小程序   scroll-view实现锚点滑动
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T15:41:00+08:00">
                2017-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>最近开始做小程序，通读一遍文档再上手并不算难，但不得不说小程序里还是有一些坑。这里说一下如何实现页面锚点跳转，一个城市列表的效果示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/6383319-104bb55559f4a26b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="city.gif"></li>
<li>因为在微信小程序的环境中不能想在浏览器里设置标签，或者操作dom滚动，传统做法就行不通了，一切都得按小程序的文档来。</li>
<li>一开始我们的做法是使用<strong>boundingClientRect()方法获取每个锚点的坐标</strong>，然后再用wx.pageScrollTo()方法滑动过去。结果发现效果不是很好，因为boundingClientRect方法返回的每个点的坐标会随着屏幕滑动而变化，可能还会引起页面抖动，<strong>最后还是选择<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/scroll-view.html" target="_blank" rel="external">scroll-view(可滚动视图区域)</a><br>组件来实现锚点效果。</strong><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3></li>
<li><p>具体API就不赘述了，可以去看官方文档，这里讲几个需要注意的地方，下面是一个示意的scroll-view组件代码，上面的几个属性是必须的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;scroll-view scroll-y style=&quot;height: 200px;&quot; bindscroll=&quot;scroll&quot; scroll-into-view=&quot;&#123;&#123;toView&#125;&#125;&quot; &gt;</div></pre></td></tr></table></figure>
</li>
<li><p>scroll-into-view：这个绑定了一个属性，它的值应该是页面元素的id，设置它的值就可以跳转到ID对应的元素那里了。</p>
</li>
<li>scroll-y：添加这个属性标明是竖向滑动的，对应的scroll-x则表示横向滑动，<strong>竖向滑动时scroll-view必须设置一个固定的height</strong></li>
<li>bindscroll：监听滑动，传给他一个事件，滑动时执行该事件</li>
<li>文档上给的属性特别多，暂时只需要上述几个就可实现我们想要的效果。实现原理也很简单，内容部分，每个英文简写的view设置一个id，然后在导航list那里点击时，就把scroll-into-view的值设置成点击的那个id即可实现跳转。</li>
<li>再说一下scroll-view的高度问题，这个一定要做适配的固定高度，不然在不同屏幕大小的手机上的显示效果有差异。<h3 id="几点优化"><a href="#几点优化" class="headerlink" title="几点优化"></a>几点优化</h3></li>
<li><p>到这里功能基本都实现了，但后面还发现一些问题：如果要隐藏scroll-view的滚动条，需要设置css样式:::-webkit-scrollbar</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">::-webkit-scrollbar &#123;</div><div class="line">	width: 0;</div><div class="line">	height: 0;</div><div class="line">	color: transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>还有就是点了一个锚点实现了跳转，这个时候你滚动页面再点之前点的锚点，页面就不会再跳转了，这个时候就需要监听滚动事件，滚动时将scroll-into-view属性的值清空。或者在每次锚点跳转后，再由一个异步操作将scroll-into-view属性的值清空。</p>
<h4 id="2017-12-05补充"><a href="#2017-12-05补充" class="headerlink" title="2017/12/05补充:"></a>2017/12/05补充:</h4></li>
<li>scroll-view默认是无滑动动画的，需要滚动的动画效果需要在组件上设置：<strong>scroll-with-animation=’true’</strong></li>
<li>关于固定高度height的设置问题，一开始我以为这个高度和滚动元素的数目/高度有关，这个时候处理动态变化的列表就很麻烦。后面在网上看到的一个方法就是使用<strong>wx.getSystemInfo</strong>方法得到windowHeight，把这个设置为scroll-view的高度(单位为px)即可。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/javascript事件流、事件代理、target和currentTarget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/31/javascript事件流、事件代理、target和currentTarget/" itemprop="url">
                  javascript事件流、事件代理、target和currentTarget
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T09:54:00+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>这篇讲的内容是非常基础的，关于javascript中的事件相关可能不太全面，只是围绕几个知识点。可能现在mvvm框架用多了也不用多去在意dom和event，但是原生的基础知识还是需要掌握的(万一以后面试问到了呢~~)</li>
<li>Javascript与html之间的交互是通过<strong>事件</strong>来实现的。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间，可以用侦听器(或处理程序)来预定事件，以便事件发生时执行相应的代码。<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3></li>
<li><strong>事件流</strong>描述的是从页面接收到事件的顺序，一些历史发展的内容这里就不提了，直接讲”DOM2级事件”，事件流包括三个阶段：<strong>事件捕获阶段、处于目标阶段和事件冒泡阶段</strong>。最先发生的是事件捕获，然后是具体的实际目标收到事件，最后才是冒泡阶段，可以在这个阶段对事件做出响应。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/6383319-f8a239bd4cb8b4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网上找的示意图.png"></p>
<h3 id="添加事件监听"><a href="#添加事件监听" class="headerlink" title="添加事件监听"></a>添加事件监听</h3><ul>
<li><p>给元素添加事件监听的方法，可以直接在html上添加或者在javascript中指定相关的<strong>事件处理程序</strong>，但是需要注意，这种以’on’开头的事件属于’DOM0’级事件，重复定义时会覆盖掉原事件，而使用addEventListener则不会覆盖之前添加的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input id=&apos;btn&apos; value=&apos;click me&apos; onclick=&apos;alert(this.value)&apos;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>还可以使用<strong>addEventListener/removeEventListener</strong>方法，所有dom节点都包含这方法，传入三个参数:事件名、处理事件的函数、标示在捕获还是在冒泡阶段调用回调函数的布尔值。</p>
</li>
<li>addEventListener添加的事件处理函数只能用removeEventListener方法移除，传入参数与addEventListener相同，<strong>意味着addEventListener添加的匿名函数无法移除，</strong>所以在用addEventListener添加处理函数时不能使用匿名函数。环境不支持addEventListener的时候，还可以使用attachEvent/detachEvent，这里就不多做介绍了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let btn = document.getElementById(&apos;btn&apos;)</div><div class="line">let handler = function () &#123;alert(this.id)&#125;</div><div class="line">btn.addEventListener(&apos;click&apos;, handler,false)</div><div class="line">btn.removeEventListener(&apos;click&apos;, handler,false)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><ul>
<li>事件委托是什么呢？最简单来说：<strong>在父元素上添加可以处理子元素事件的事件处理函数</strong>。利用了事件冒泡，指定一个事件处理函数，来处理同一种类型的多个事件。这里顺便一起说下target和currenttarget的区别，<strong>target是触发事件的最具体的元素， currenttarget是绑定事件的元素(在函数中一般等于this)</strong>。下面具体代码示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;outter&quot;&gt;</div><div class="line">   &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var outter = document.querySelector(&apos;#outter&apos;)</div><div class="line">outter.addEventListener(&apos;click&apos;,function(e)&#123;</div><div class="line">    console.log(e.target.id)  //inner</div><div class="line">    console.log(e.currentTarget.id)  //outter</div><div class="line">    console.log(this === e.currentTarget)  //true</div><div class="line">&#125;,false);</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/手写JSONP-promise封装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/14/手写JSONP-promise封装/" itemprop="url">
                  手写JSONP(promise封装)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T15:41:00+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>JSONP以前研究过，最近又有点忘了，写篇本文mark一下，旨在理解记住JSONP的原理及其实现。代码实现用到es6语法，使用promise来封装JSONP方法，本地测试用的自己node搭的服务器,具体代码就不贴了。</li>
<li>一句话阐述下JSONP原理：<strong><em>动态生成一个JavaScript标签，其src由接口url、请求参数、callback函数名拼接而成，利用js标签没有跨域限制的特性实现跨域请求。</em></strong></li>
<li>有几点需要注意：1.callback函数要绑定在window对象上<br>2.服务端返回数据有特定格式要求：callback函数名+’(‘+JSON.stringify(返回数据) +’)’<br>3.不支持post，因为js标签本身就是一个get请求</li>
<li>具体代码如下，最后一段是调用函数的示例，这个函数将返回一个promise对象，获取到数据时状态为resolve<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">const jsonp = function (url, data) &#123;</div><div class="line">  return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">    // 初始化url</div><div class="line">    let dataString = url.indexOf(&apos;?&apos;) === -1 ? &apos;?&apos; : &apos;&amp;&apos;</div><div class="line">    let callbackName = `jsonpCB_$&#123;Date.now()&#125;`</div><div class="line">    url += `$&#123;dataString&#125;callback=$&#123;callbackName&#125;`</div><div class="line">    if (data) &#123;</div><div class="line">     // 有请求参数，依次添加到url</div><div class="line">      for (let k in data) &#123;</div><div class="line">        url += `&amp;$&#123;k&#125;=$&#123;data[k]&#125;`</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    let jsNode = document.createElement(&apos;script&apos;)</div><div class="line">    jsNode.src = url</div><div class="line">    // 触发callback，触发后删除js标签和绑定在window上的callback</div><div class="line">    window[callbackName] = result =&gt; &#123;</div><div class="line">      delete window[callbackName]</div><div class="line">      document.body.removeChild(jsNode)</div><div class="line">      if (result) &#123;</div><div class="line">        resolve(result)</div><div class="line">      &#125; else &#123;</div><div class="line">        reject(&apos;没有返回数据&apos;)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    // js加载异常的情况</div><div class="line">    jsNode.addEventListener(&apos;error&apos;, () =&gt; &#123;</div><div class="line">      delete window[callbackName]</div><div class="line">      document.body.removeChild(jsNode)</div><div class="line">      reject(&apos;JavaScript资源加载失败&apos;)</div><div class="line">    &#125;, false)</div><div class="line">    // 添加js节点到document上时，开始请求</div><div class="line">    document.body.appendChild(jsNode)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line">jsonp(&apos;http://192.168.0.103:8081/jsonp&apos;, &#123;a: 1, b: &apos;heiheihei&apos;&#125;)</div><div class="line">  .then(result =&gt; &#123; console.log(result) &#125;)</div><div class="line">  .catch(err =&gt; &#123; console.error(err) &#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>个人感觉JSONP用的情况还是比较少吧，如果已经是需要服务端配合来进行跨域的情况，为什么不直接用CORS呢</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/11/使用eslint检查JS代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/11/使用eslint检查JS代码/" itemprop="url">
                  使用eslint检查JS代码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-11T16:13:00+08:00">
                2017-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>代码规范一直是开发过程中比较重要的一环，包括命名规范、统一缩进等等，规范整洁的代码可读性高，也便于后期代码维护以及其他开发人员快速熟悉；本篇就讲一下eslint的具体用法。</li>
</ul>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>eslint早在2013年就有了，而我个人第一次接触还是在使用vue-cli搭建项目的时候，默认配置的eslint会根据规则直接报错，刚开始用的时候满屏报错、特别酸爽~~ 但只要习惯就好，使用eslint检查代码会使你的js文件更加健壮好看。</li>
</ul>
<h4 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h4><ul>
<li>首先安装eslint，直接 <strong>npm install eslint</strong>即可，注意如果你是全局安装的eslint，后面一些eslint相关依赖包也要全局安装。</li>
<li><p>然后输入 <strong>eslint init</strong> 开始初始化一个配置文件，过程中会给你很多选项，比如是否使用es6、是否使用jsx语法、配置文件的文件格式等等。我选择的生成js配置文件，所有选项都选好后，生成一个<strong>.eslintrc.js</strong>配置文件内容大概长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">    &quot;env&quot;: &#123;</div><div class="line">        &quot;browser&quot;: true,</div><div class="line">        &quot;es6&quot;: true</div><div class="line">    &#125;,</div><div class="line">    &quot;extends&quot;: &quot;eslint:recommended&quot;,</div><div class="line">    &quot;parserOptions&quot;: &#123;</div><div class="line">        &quot;sourceType&quot;: &quot;module&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;rules&quot;: &#123;</div><div class="line">        &quot;indent&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;tab&quot;</div><div class="line">        ],</div><div class="line">        &quot;linebreak-style&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;windows&quot;</div><div class="line">        ],</div><div class="line">        &quot;quotes&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;double&quot;</div><div class="line">        ],</div><div class="line">        &quot;semi&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;never&quot;</div><div class="line">        ],</div><div class="line">        &quot;no-console&quot;: 0 </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>其中最重要的就是<strong>rules</strong>里面配置的规则，eslint会根据这里是配置的rule规则对代码进行检验，键值分别对应规则名和状态，比如”no-console“是规则名，后面对应的0表示不执行这条规则。extends表示继承自哪个共享的配置文件，env表示检查代码时所属的环境。</p>
</li>
<li>具体状态码规则是这样：  <strong>0</strong>或者“<strong>off</strong>”表示关闭规则； <strong>1</strong>或者<strong>warn</strong>表示开启规则，使用警告级别的错误； <strong>2</strong>或者<strong>error</strong>表示开启规则，使用错误级别的错误：error (当被触发的时候，程序会报错)</li>
<li>配置完成后，在当前目录新建一个index.js文件，随便输入几行代码，<strong>然后在命令行输入eslint index.js</strong>。就会对js文件进行代码检查，如果代码报错，命令行会提示你多少行触发了哪条规则的错误，你就可以对代码进行改正，或者修改配置文件中的rule规则。</li>
<li>配置eslint的方法还有其他的，比如写在package.json中：新增一个eslintConfig，将上述配置文件的内容放在下面。但我个人还是喜欢用单独的配置文件，来控制eslint。<h4 id="集成到webpack"><a href="#集成到webpack" class="headerlink" title="集成到webpack"></a>集成到webpack</h4></li>
<li>接下来介绍一下如何把eslint集成到webpack中。首先确保webpack已经安装好，然后依次安装eslint-loader、eslint-config-standard、eslint-plugin-html、eslint-plugin-promise、eslint-plugin-standard、eslint-friendly-formatter。注意如果eslint是全局安装的，这些依赖包也需要全局安装，否则报错找不到对应的包。</li>
<li><p><strong>然后新建一个webpack的配置文件webpack.config.js</strong>，我这里只是做尽量最少的配置，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    entry: &#123;</div><div class="line">        index: &quot;./src/index.js&quot;,</div><div class="line">    &#125;,</div><div class="line">    output: &#123;</div><div class="line">        path: __dirname + &quot;/dist/&quot;,</div><div class="line">        filename: &quot;[name].js&quot;</div><div class="line">    &#125;,</div><div class="line">    resolve: &#123;</div><div class="line">        extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;]</div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">         rules: [</div><div class="line">                &#123;</div><div class="line">                    test: /\.js$/,</div><div class="line">                    exclude: /node_modules/,</div><div class="line">                    loaders: [</div><div class="line">                        &apos;eslint-loader&apos;</div><div class="line">                    ]</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    test: /\.vue|\.js$/,</div><div class="line">                    enforce: &apos;pre&apos;,  // 在babel-loader对源码进行编译前进行lint的检查</div><div class="line">                    include: /src/,  // src文件夹下的文件需要被lint</div><div class="line">                    use: [&#123;</div><div class="line">                        loader: &apos;eslint-loader&apos;,</div><div class="line">                        options: &#123;</div><div class="line">                            formatter: require(&apos;eslint-friendly-formatter&apos;)   // 编译后错误报告格式</div><div class="line">                        &#125;</div><div class="line">                    &#125;]</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这时候文件目录结构如下图<br><img src="http://upload-images.jianshu.io/upload_images/6383319-f6ea3f19ed2c3380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件结构"></p>
</li>
<li>这时在src文件夹下新建index.js文件，命令行输入webpack进行代码打包的过程会使用eslint进行检查，如果无误就在dist/js文件夹下生产打包后的代码，如果检查报错则在命令行中打印出错误位置和触犯的规则。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/27/从几个关键词来理解http缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/27/从几个关键词来理解http缓存/" itemprop="url">
                  从几个关键词来理解http缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-27T15:19:00+08:00">
                2017-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>我对于http缓存的认知总是停留在略知一二的状态，毕竟实际工作中用的比较少-_-||<br>但作为一个严谨的程序员，这仍是必备的一个知识技能。想了想还是写篇博客来总结下相关的一些知识，从一些关键词来理解http的缓存<h5 id="强缓存与协商缓存"><a href="#强缓存与协商缓存" class="headerlink" title="强缓存与协商缓存"></a>强缓存与协商缓存</h5></li>
<li>首先需要知道的是读取http缓存的方式是有两种的：<strong>强缓存(本地缓存)</strong>和<strong>协商缓存(对比缓存)</strong>，下面讲一下这两种工作方式的区别和特点。</li>
<li><p><strong>强缓存</strong>： 客户端发送请求时，首先访问浏览器的缓存数据库，若得知缓存存在且有效，则直接读取缓存内容返回给客户端，此时返回状态码为<strong>200（from cache）</strong>;而如果发现缓存失效了或不存在，则会去请求<strong>服务器</strong>得到相关内容信息，此时返回状态码为200，操作示意图如下<br><img src="http://upload-images.jianshu.io/upload_images/6383319-5018186b2e518efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="强缓存.png"></p>
</li>
<li><p><strong>协商缓存</strong>： 客户端发送请求时，如果是第一次请求资源，则直接访问服务器，服务器将相关内容和缓存标示返回给客户端；如果是再次请求资源，<strong>客户端将第一次访问时服务器返回的缓存标示发送给服务器，服务器来判断缓存是否可用，</strong>如果缓存可用则告诉客户端可以继续使用缓存的内容，此时<strong>返回码为304</strong>，操作示意图如下<br><img src="http://upload-images.jianshu.io/upload_images/6383319-e872781570ae4356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协商缓存.png"></p>
</li>
<li>综上可以直观的看出两种方式的区别，最明显的是<strong>缓存命中时返回码不同</strong>，还有对比缓存的方式：<strong>每一次都会去访问服务器，无论缓存命中与否</strong>。那么对于浏览器和服务器是如何区分强缓存还是对比缓存，以及如何判断缓存是否有效呢，这就需要那些放在<strong>http报文header中</strong>的相关字段了，接下来依次讲解他们。ps：两种缓存方式是可以同时存在的，同时存在时，强缓存的优先级更高。<h4 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h4></li>
<li>用于定义强缓存的header字段，这是http1.0时的规范，它的值为一个GMT格式时间字符串，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。但是已经过时了，基本可以忽略。<h4 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h4></li>
<li>http1.1版本出现的header信息，用来定义缓存信息。包括了好几个字段，其中最重要的就是<strong>max-age</strong>：用于表示缓存多少秒后失效。比如max-age = 31536000，表示缓存时间为365天，从第一次请求后的365天内再次请求都会去读取缓存。这个也是用来控制强制缓存的header字段。<h5 id="协商缓存相关的header字段"><a href="#协商缓存相关的header字段" class="headerlink" title="协商缓存相关的header字段"></a>协商缓存相关的header字段</h5></li>
<li>协商缓存的方式总是会去访问服务器来确定缓存是否可用的，所以需要通过某种标识来进行通信，主要包括下面两组header字段(他们都是要成对出现)，即第一次请求的响应头带上某个字段（<strong>Last-Modified/Etag</strong>），则后续请求头则会带上对应的请求字段（<strong>If-Modified-Since/If-None-Match</strong>），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。<h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified  /  If-Modified-Since"></a>Last-Modified  /  If-Modified-Since</h5></li>
<li>这组值都是时间字符串。具体行为如下：第一次请求时服务器返回的response headers带上<strong>Last-Modified字段表示资源最后一次修改的时间</strong>，再次请求时浏览器的request headers带上<strong>If-Modified-Since</strong>这个值和第一次访问返回的Last-Modified值是一样的，然后给到服务器再进行判断缓存是否过期<h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h5></li>
<li>这组字段的值是服务器生成的唯一标示字符串，用法和上面的Last-Modified/If-Modified-Since类似，第一次访问时服务器会返回一个Etag，再次访问浏览器就会带上If-None-Match其值为第一次返回的Etag，给到服务器，服务器进行判断缓存是否可用。ps: Etag和Last-Modified同时使用时，服务器会<strong>优先判断Etag</strong>，好像是etag的精准级别更高。<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4></li>
<li>大概就这么多了，都是以最基本的概念为主，参考了一些网上的资料，如果有机会的话再深入地研究下~~~<br>参考：<a href="http://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="external">彻底弄懂HTTP缓存机制及原理</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="TokenYangForever" />
          <p class="site-author-name" itemprop="name">TokenYangForever</p>
           
              <p class="site-description motion-element" itemprop="description">放点随笔文章</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TokenYangForever</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
