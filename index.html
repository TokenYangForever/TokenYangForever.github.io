<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="放点随笔文章">
<meta property="og:type" content="website">
<meta property="og:title" content="唐洋洋的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="唐洋洋的个人博客">
<meta property="og:description" content="放点随笔文章">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="唐洋洋的个人博客">
<meta name="twitter:description" content="放点随笔文章">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 唐洋洋的个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">唐洋洋的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">\(^o^)/~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/18/使用Javascript做算法题（四）Longest-Increasing-Path-in-a-Matrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/18/使用Javascript做算法题（四）Longest-Increasing-Path-in-a-Matrix/" itemprop="url">
                  使用Javascript做算法题（四）Longest Increasing Path in a Matrix
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-18T22:21:00+08:00">
                2017-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode算法题/" itemprop="url" rel="index">
                    <span itemprop="name"> leetcode算法题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>最近在LeetCode上做出了第一道难度为hard的题：) 觉得这题中规中矩挺不错的，mark一下：<a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/" target="_blank" rel="external">题目地址</a></li>
</ul>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><ul>
<li>给出一个正整数矩阵，找出其中<strong>最长的递增路径的长度</strong>。只能上下左右移动，不能走对角线，不能环绕重复路线，不能超越边距。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">举例：</div><div class="line">输入:</div><div class="line">nums = [</div><div class="line">  [9,9,4],</div><div class="line">  [6,6,8],</div><div class="line">  [2,1,1]</div><div class="line">]</div><div class="line">返回 最长路径为4 路径为：1-&gt;2-&gt;6-&gt;9</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>基本思路分以下几个点：</li>
<li>0.依次遍历输入的矩阵(二维数组)，找出每个点作为起点时的最长递归路径长度，然后返回其中的最大值</li>
<li>1.使用dfs递归方法去遍历查找各个方向，建立一个表示移动方向的数组，每次dfs查找一个新的节点是遍历这个数组，得出最大值作为这个点为起点的最长路径，保存到dp中</li>
<li>2.新建一个二维数组作为dp数组，每次得到一个坐标点为起点的最大长度时存入dp数组相应位置，以后再查找到这个坐标点时直接返回之前保存的值避免重复运算</li>
<li>上面可能说的有点乱，大概就是dfs遍历和dp数组结合，难度其实并不算大，但是可以优化的细节还是挺多的，下面代码附有具体注释</li>
</ul>
<h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[][]&#125; matrix</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var longestIncreasingPath = function(matrix) &#123;</div><div class="line">    if (!matrix || matrix.length === 0) &#123;</div><div class="line">        return 0</div><div class="line">    &#125;</div><div class="line">          </div><div class="line">    var direct = [[0, -1], [0, 1], [-1, 0], [1, 0]] // 方向数组</div><div class="line">    var max = 1 // 全局最大值</div><div class="line">    var dp = new Array() // dp二维数组，保存每个点作为起点的最大路径长度</div><div class="line">    var width = matrix[0].length</div><div class="line">    var deep = matrix.length</div><div class="line">    while (deep) &#123; </div><div class="line">        dp.push(new Array(width).fill(0)) // 每个点初始长度为0，dfs遍历到不为0的情况直接返回她的值(因为是之前已经得到了)</div><div class="line">        deep--</div><div class="line">    &#125;</div><div class="line">    deep = matrix.length</div><div class="line">    </div><div class="line">    var dfs = function (i, j) &#123;</div><div class="line">        if (dp[i][j] &gt; 0) return dp[i][j];</div><div class="line">        var mx = 1</div><div class="line">        for (var k = 0; k &lt; direct.length; k++) &#123;</div><div class="line">            var x = i + direct[k][0]</div><div class="line">            var y = j + direct[k][1]</div><div class="line">            if (x &lt; 0 || x &gt;= deep || y &lt; 0 || y &gt;=width) &#123; // 超过范围跳过</div><div class="line">                continue</div><div class="line">            &#125;</div><div class="line">            if (matrix[x][y] &lt;= matrix[i][j]) &#123;// 不是递增跳过</div><div class="line">                continue</div><div class="line">            &#125;</div><div class="line">            var len = dfs(x, y) + 1</div><div class="line">            mx = Math.max(mx, len)</div><div class="line">        &#125;</div><div class="line">        dp[i][j] = mx</div><div class="line">        return mx</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (var i = 0; i &lt; deep; i++) &#123;</div><div class="line">        for (var j = 0; j &lt; width; j++) &#123;</div><div class="line">            max = Math.max(max, dfs(i, j))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return max</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/18/python入门-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/18/python入门-二/" itemprop="url">
                  python入门(二)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-18T17:08:00+08:00">
                2017-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>python中自带一些全局函数，比如在js中封装在math对象的数学方法：max、min、abs，也有可以用于数据转换的函数：int、str；用于遍历的方法：all、any。官网上可以看到<a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="external">https://docs.python.org/3/library/functions.html</a></li>
</ul>
<h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><ul>
<li>def 用来定义函数。</li>
<li>isinstance()方法可以用来判断参数类型，第一个参数是需要判断的对象，第二参数是候选的变量类型，多个类型之一的话要用tuple类型表示<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">isinstance(x, (int, float))</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="定义空函数"><a href="#定义空函数" class="headerlink" title="定义空函数"></a>定义空函数</h4><ul>
<li>pass相当于一个占位符，表示什么也不做<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def nop():</div><div class="line">    pass</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="设置函数的默认参数"><a href="#设置函数的默认参数" class="headerlink" title="设置函数的默认参数"></a>设置函数的默认参数</h4><ul>
<li>使用等号设置参数的默认值，和es6语法一致。需要注意的是：必选参数在前，默认参数在后</li>
<li>定义默认参数要牢记一点：默认参数必须指向不变对象！<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def power(x, n=2):</div><div class="line">    s = 1</div><div class="line">    while n &gt; 0:</div><div class="line">        n = n - 1</div><div class="line">        s = s * x</div><div class="line">    return s</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="定义可变参数"><a href="#定义可变参数" class="headerlink" title="定义可变参数"></a>定义可变参数</h4><ul>
<li><p>类似于es6中的…(function (…args) {})，这里的numbers是一个tuple类型的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def calc(*numbers):</div><div class="line">    sum = 0</div><div class="line">    for n in numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    return sum</div></pre></td></tr></table></figure>
</li>
<li><p>传入参数时也可以使用*把数组[]和元组()类型的参数 =&gt; 变成可变参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">calc(*[1,2,3], *(4,5,6))</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><ul>
<li>python中传入参数时，可以用关键字来修饰参数，这样甚至就可以不用考虑传参的顺序。</li>
<li>未出现在参数中的关键字参数会进入other(一个dict类型的数据)里面，同样的也可以使用**来讲dict类型的数据转换成可变参数传入。</li>
<li><p>注意：多余的未知参数会进入到args中，多余的关键字参数则会进入到other中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def person(name, age, *args, **other):</div><div class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, other, &apos;args:&apos;, args)</div><div class="line"># person(age=45, name=&apos;Adam&apos;)</div><div class="line">person(&apos;Adam&apos;, 45, 123, 456, yaho=&apos;lalala&apos;, **&#123;&apos;city&apos;:&apos;Beijing&apos;, &apos;job&apos;:&apos;Engineer&apos;&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>但是使用关键字参数时有很多限定条件：关键字参数必须放在一般参数的后面</p>
</li>
</ul>
<h4 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h4><ul>
<li>定义参数时，跟在<em>或者可变参数(</em>args)后面的参数，被视为命名关键字参数，这些参数在调用函数传参时，<strong>必须传入参数名。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def person(name, age, *或者*args, city, job):</div><div class="line">    print(name, age, city, job)</div><div class="line">person(&apos;Adam&apos;, 45, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h4><ul>
<li>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</li>
</ul>
<h4 id="说一句递归"><a href="#说一句递归" class="headerlink" title="说一句递归"></a>说一句递归</h4><ul>
<li>python并不能实现尾调用优化，递归调用函数时，每一次调用都会增加一次栈帧，超过上线后就会报错。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/14/python入门-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/14/python入门-一/" itemprop="url">
                  python入门(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-14T20:53:00+08:00">
                2017-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h3><ul>
<li>Python是用来编写应用程序的<strong>高级</strong>编程语言</li>
<li>Python为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”</li>
</ul>
<h3 id="Python特-缺-点"><a href="#Python特-缺-点" class="headerlink" title="Python特(缺)点"></a>Python特(缺)点</h3><ul>
<li>第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是<strong>解释型语言</strong>，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。</li>
<li>第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，<strong>凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。</strong></li>
</ul>
<h3 id="Python-安装"><a href="#Python-安装" class="headerlink" title="Python 安装"></a>Python 安装</h3><ul>
<li>mac上面:安装Homebrew后，直接通过命令brew install python3安装即可。</li>
</ul>
<h3 id="编辑器和解释器"><a href="#编辑器和解释器" class="headerlink" title="编辑器和解释器"></a>编辑器和解释器</h3><ul>
<li>python是解释型语言，使用上面的命令安装后就有自带的解释器。在命令行输入python可以进入python交互模式，类似于node。输入python3 文件名.py即可执行python文件</li>
<li>文本编辑器使用sublime Text即可</li>
</ul>
<h3 id="python基础语法"><a href="#python基础语法" class="headerlink" title="python基础语法"></a>python基础语法</h3><ul>
<li>Python的语法比较简单，采用缩进方式，循环条件语句都不需要括号</li>
<li>Python区分大小写</li>
<li>python中能直接处理的数据类型：整数、浮点数、字符串、布尔值、空值(None)。也有变量，变量不需要声明类型。</li>
<li>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错(比如java)。</li>
<li>一些操作符：and == &amp;&amp; . . . or == || . . . 10 // 3 = 1 (Math.floor(10/3))</li>
<li>str通过encode()方法可以编码为指定的bytes，相反的有decode方法</li>
<li>使用 % 来格式化字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a>list和tuple</h4><p>python内置list类型(相当于数组)；有序列表：tuple(元组)，tuple一旦初始化就不能修改；只有1个元素的tuple定义时必须加一个逗号，来消除歧义</p>
<h4 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h4><ul>
<li><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;</div><div class="line">d[&apos;Michael&apos;]</div></pre></td></tr></table></figure>
</li>
<li><p>dict获取值的方法：get()获取，第二个参数是取不到的时候返回值避免报错，key in d也可以判断dict中是否有对应的键值。不能用点.操作符！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d.get(&apos;Thomas&apos;, -1)</div></pre></td></tr></table></figure>
</li>
<li><p>dict与list区别：dict查找和插入速度快，但是占用空间和资源更多。</p>
</li>
<li>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。</li>
<li>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。(只是一组无重复的不可变对象的key？)</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>这里我就对python和JavaScript在语法上进行一个初步的比较：</li>
</ul>
<ol>
<li>两者都是解释形的弱类型语言，变量的类型可随时改变。</li>
<li>在python中的数据类型更多：比如类似于js数组的就有list/tuple。他们之间的比较后面有时间我再深入了解下。</li>
<li>条件语句以及循环语句都是类似的，但是在python中没有用大括号{}来表示层级结构，而是通过冒号:以及缩进来控制的。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/13/用react-native实现一个数独游戏-总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/13/用react-native实现一个数独游戏-总结/" itemprop="url">
                  用react-native实现一个数独游戏(总结)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-13T15:41:00+08:00">
                2017-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/react-native/" itemprop="url" rel="index">
                    <span itemprop="name">react-native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>最近用react-native做了一个数独游戏的app，到今天基本功能已经全都完成并打包在真机上测试了，这里总结一下开发过程中的一些问题和实现的思路。<br><img src="http://upload-images.jianshu.io/upload_images/6383319-c4e4dbb2eaf0a4ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<h4 id="环境和平台选择"><a href="#环境和平台选择" class="headerlink" title="环境和平台选择"></a>环境和平台选择</h4><ul>
<li>项目上读取的接口是我自己服务器上部署的，用node实现的接口，链接mysql数据库，数独题目就是从这里读取得到。因为服务器上只有http接口，所以app开发时也就选择的android版本。</li>
</ul>
<h4 id="功能及实现"><a href="#功能及实现" class="headerlink" title="功能及实现"></a>功能及实现</h4><ul>
<li>因为只是一个简单的demo，做的功能也比较简单：新游戏/继续游戏/选择难度。页面有三个：首页/棋盘页面/关于。</li>
<li><p>页面导航使用的react-navigation，从首页进入棋盘页面时，会传参数过去表示是否是新游戏和游戏难度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.props.navigation.navigate(&apos;Main&apos;, &#123;difficulty: text, newgame: true&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>数独棋盘的生成，是从数据库得到数据，然后再渲染出来。一开始我是打算随机生成棋盘的，但是发现生成的棋盘可能会出现多解的情况，最后想想还是算了，在网上找了几个数独题目存在数据库里。</p>
</li>
<li><p>触发提交按钮后，会对棋盘进行验证，有空白没有填完则返回，然后再依次判断各个点是否满足数独条件，判断方法可参考LeetCode上的一道题：<a href="https://leetcode.com/problems/valid-sudoku/description/" target="_blank" rel="external">Valid Sudoku</a>，下面还是贴下判断结果的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">let arr = this.state.arr</div><div class="line">let dp = &#123;&#125;</div><div class="line">let index = 0</div><div class="line">for (let a = 0; a &lt; 3; a++) &#123;</div><div class="line">  for (let b = 0; b &lt; 3; b++) &#123;</div><div class="line">    dp[`area$&#123;a&#125;$&#123;b&#125;`] = new Map()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">for (let i = 0; i &lt; 9; i++) &#123;</div><div class="line">  dp[`x$&#123;i&#125;`] = new Map()</div><div class="line">  dp[`y$&#123;i&#125;`] = new Map()</div><div class="line">&#125;</div><div class="line">for (let i = 0; i &lt; 9; i++) &#123;</div><div class="line">  for (let j = 0; j &lt; 9; j++) &#123;</div><div class="line">    let temp = arr[index]</div><div class="line">    if (temp !== &apos;&apos;) &#123;</div><div class="line">      let xIndex = &apos;x&apos; + j</div><div class="line">      let yIndex = &apos;y&apos; + i</div><div class="line">      let areaIndex = &apos;area&apos; + Math.floor(j/3) + Math.floor(i/3)</div><div class="line">      if (dp[xIndex].has(temp) || dp[yIndex].has(temp) || dp[areaIndex].has(temp)) &#123;</div><div class="line">        return [false, &apos;有空格填错了哦~&apos;, index]</div><div class="line">      &#125; else &#123;</div><div class="line">        dp[xIndex].set(temp, true)</div><div class="line">        dp[yIndex].set(temp, true)</div><div class="line">        dp[areaIndex].set(temp, true)</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      return [false, &apos;还有空格没填完哦~&apos;]</div><div class="line">    &#125;</div><div class="line">    index++</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">return [true]</div></pre></td></tr></table></figure>
</li>
<li><p>数据存储还是使用的react-native提供的AsyncStorage，并对其进行一层包装。未完成的棋局缓存起来，继续游戏的时候再调用。</p>
</li>
<li>基本上就是这些了，以后有机会再补充。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/react-native-react-开发中遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/06/react-native-react-开发中遇到的问题/" itemprop="url">
                  react-native/react 开发中遇到的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T16:26:00+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/react-native/" itemprop="url" rel="index">
                    <span itemprop="name">react-native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>最近对react-native产生些兴趣，准备学一学，写写demo练练手，然而之前对react页不是很熟悉，所以一边学一边写code，一边看react-native的文档一边撘环境。中途还是遇到很多问题，写篇文章mark下。</li>
</ul>
<h4 id="react-native搭建开发环境时遇到的问题"><a href="#react-native搭建开发环境时遇到的问题" class="headerlink" title="react-native搭建开发环境时遇到的问题"></a>react-native搭建开发环境时遇到的问题</h4><ul>
<li>搭建Android开发环境：</li>
</ul>
<ol>
<li>java版本不能装9.0+的，路径格式不同，Android-studio无法识别路径。</li>
<li>Android SDK 要装25.0+的，不然会提示版本过低无法继续，然而教程(甚至是fb官网上)还是写的装23.0</li>
<li>模拟器，先在Android-studio打开Android模拟器之后，再在命令行执行react-native run-android命令</li>
<li>执行react-native run-*命令时，启动的packager server需要使用8081端口，确保这个端口没有占用！</li>
</ol>
<h4 id="RN中写样式"><a href="#RN中写样式" class="headerlink" title="RN中写样式"></a>RN中写样式</h4><ul>
<li>本来平时我css就写得少，RN中这种变种的css写起来更蛋疼。。。。<a href="https://github.com/doyoe/react-native-stylesheet-guide" target="_blank" rel="external">React-Native 样式指南</a></li>
<li>RN中的样式相当于css的缩减版，命名方式要用驼峰法，然后大部分属性都能和css中对应。布局：也有相对定位和绝对定位，也支持flex。<strong>官方推荐flex</strong>，可以解决大多数的布局情况。</li>
<li>建议使用StyleSheet.create()生成样式的类名，也可以直接在组件上写”内联”样式。</li>
<li>RN中元素的<strong>宽高是没有单位的</strong>，直接用数字表示即可，也可以用flex来实现弹性宽高。</li>
<li>另外就是要注意，不同的组件可以设置的样式是不同的，比如遇到无法设置宽高的组件就只能在它外层包个view，然后设置这个view的宽高。</li>
</ul>
<h4 id="RN中调试"><a href="#RN中调试" class="headerlink" title="RN中调试"></a>RN中调试</h4><ul>
<li>打开调试菜单：iOS模拟器中：Command⌘ + D 快捷键；Android模拟器对应的则是Command⌘ + M</li>
<li>Enable Live Reload：开启自动刷新</li>
<li>Enable Hot Reload：开启热加载</li>
<li>访问控制台日志:在终端中运行：react-native log-ios或者log-android</li>
<li>在开发者菜单中选择”Debug JS Remotely”选项，即可以开始在Chrome中调试JavaScript代码。点击这个选项的同时会自动打开调试页面 <a href="http://localhost:8081/debugger-ui" target="_blank" rel="external">http://localhost:8081/debugger-ui</a>.</li>
<li>注:Chrome中并不能直接看到App的用户界面，而只能提供console的输出，以及在sources项中断点调试js脚本。</li>
</ul>
<h4 id="RN中的网络通信"><a href="#RN中的网络通信" class="headerlink" title="RN中的网络通信"></a>RN中的网络通信</h4><ul>
<li>文档上介绍的是使用fetch，我也专门去了解了一下下，算是ajax的进化版，结合了一些html5的新特性。RN中也支持websocket。</li>
<li>默认情况下，iOS会阻止所有非https的请求。如果你请求的接口是http协议，那么首先需要添加一个App Transport Security的例外，详细可参考<a href="https://segmentfault.com/a/1190000002933776" target="_blank" rel="external">这篇帖子</a>。</li>
</ul>
<h4 id="RN中的数据存储"><a href="#RN中的数据存储" class="headerlink" title="RN中的数据存储"></a>RN中的数据存储</h4><ul>
<li>在浏览器环境，我们可以使用cookie、localstorage或者sessionstorage来实现数据缓存，在RN中则不能使用以上的三种方式。</li>
<li><a href="http://reactnative.cn/docs/0.50/asyncstorage.html#content" target="_blank" rel="external">AsyncStorage</a>是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的。它用来代替LocalStorage。</li>
</ul>
<h4 id="react相关"><a href="#react相关" class="headerlink" title="react相关"></a>react相关</h4><ul>
<li><p>react事件需要手动绑定this，或者使用箭头函数来声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">this.handleClick = this.handleClick.bind(this);</div><div class="line">// 或者</div><div class="line">onClick=&#123;(e) =&gt; this.handleClick(e)&#125;</div><div class="line">handleClick = () =&gt; &#123;...&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>react的组件必须以大写字母命名: 小写字母的标签会被认为是html的标签而不会被编译。一般表达式声明react的组件也要用大写字母开头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const SpecificStory = components[props.storyType];</div><div class="line">  return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/Fetch初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/22/Fetch初探/" itemprop="url">
                  Fetch初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T13:34:00+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Html/" itemprop="url" rel="index">
                    <span itemprop="name">Html</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>fetch这个东西，之前也看到过有人介绍，但毕竟还是实验性阶段的东西，最近在看react-native的文档，讲到网络的地方，文档上是推荐地使用fetch，想必框架本身也对其有所封装。这里就先自己学习一下fetch相关的基础知识。</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="external">Fetch</a> 是一个现代的概念, 等同于<a href="https://developer.mozilla.org/enUS/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a>。它提供了许多与XMLHttpRequest相同的功能，但被设计成更具可扩展性和高效性。下图显示了fetch在浏览器中的支持情况，可以看到在主流浏览器的支持性还是不错的，实在不支持fetch的浏览器(比如IE)上面也可以使用相应的polyfill库。<br><img src="http://upload-images.jianshu.io/upload_images/6383319-9575a5a9c01ac1fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fetch在浏览器中的支持情况.png"></li>
</ul>
<h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4><ul>
<li><p>使用fetch首先需要具备promise的相关知识，还涉及到一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response" target="_blank" rel="external">Response</a>对象，直接来看下代码，这是一段调用json格式数据接口的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fetch(&apos;http://101.200.35.148:8081/todo/getTodo&apos;)</div><div class="line">  .then(response =&gt; &#123;</div><div class="line">    response.json().then(</div><div class="line">        // 这里的result就是最终的接口数据了</div><div class="line">        result =&gt; &#123;</div><div class="line">          console.log(result)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>在支持fetch的浏览器中，fetch方法是global的可以直接调用。上述代码是一个get请求(默认方法是get)，fetch执行后会返回一个promise对象，这个promise对象resolve之后得到一个response对象(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response" target="_blank" rel="external">Response</a>的实例)。</p>
</li>
<li><strong>response对象</strong>相当于整个流程中的一个中间状态，它自带一个json方法用于解析从接口得到的数据，还有一个属性bodyUsed标识是否已经被解析，response.json()执行后也是返回一个promise对象，正确执行后then()这里得到的result对象就是最终的接口数据了。执行完json方法后，response对象的bodyUsed会变成true，表示这个response对象是已经被读取过了的，这时候如果再次调用response的json方法就会报错。</li>
</ul>
<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><ul>
<li><p>接着来看下fetch如何处理post请求，fetch方法可以接收第二个参数来设置发送请求的方法、header、请求参数等，下面是一个post请求的示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fetch(&quot;/post/api/&quot;, &#123;</div><div class="line">    method: &quot;POST&quot;,</div><div class="line">    body: &quot;A=参数A&amp;B=参数B&quot;,</div><div class="line">    headers: new Headers()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>其中body就表示请求参数，可根据具体情况自行调整数据结构;method设定请求方法，默认为get大小写皆可，headers用于设置发送请求的header。fetch在请求post的时候如果没有成功，则会尝试重新以get方法发送请求。</p>
</li>
</ul>
<h4 id="使用async-await"><a href="#使用async-await" class="headerlink" title="使用async/await"></a>使用async/await</h4><ul>
<li>因为多了一层response，这里的promise回调代码结构就略显复杂，所以用fetch时使用async/await代码就会精简许多，可读性也会大大提高，比如下面这样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">async componentDidMount () &#123;</div><div class="line">  try &#123;</div><div class="line">    let res = await fetch(&apos;http://101.200.35.148:8081/todo/getTodo&apos;)</div><div class="line">    let &#123;result&#125; = await res.json()</div><div class="line">    this.setState(&#123;</div><div class="line">      result</div><div class="line">    &#125;)</div><div class="line">  &#125; catch(e) &#123;</div><div class="line">    console.log(e)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h4><ul>
<li><p>fetch除了用于post/get调取接口以外还可以请求图片，下面是一段请求图片，然后将图片显示在dom上的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var myImage = document.querySelector(&apos;img&apos;);</div><div class="line"></div><div class="line">fetch(&apos;flowers.jpg&apos;)</div><div class="line">.then(function(response) &#123;</div><div class="line">  return response.blob();</div><div class="line">&#125;)</div><div class="line">.then(function(myBlob) &#123;</div><div class="line">  var objectURL = URL.createObjectURL(myBlob);</div><div class="line">  myImage.src = objectURL;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>可以看到代码第一步还是获取response对象，之后调用了response.blob()来得到一个blob对象，这里又涉及到了另一个新特性<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="external">Blob</a>，继续调用URL.createObjectURL可将blob对象转换为一个临时链接供img标签使用。Blob相关暂不多做介绍，这里只是为了说明一下fetch还有这一种用法。</p>
</li>
<li>参考： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/17/JavaScript中的-抽象语法树-AST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/17/JavaScript中的-抽象语法树-AST/" itemprop="url">
                  JavaScript中的 抽象语法树 AST
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-17T17:40:00+08:00">
                2017-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><ul>
<li>抽象语法树（Abstract Syntax Tree）也称为AST语法树，指的是源代码语法所对应的树状结构。也就是说，一种编程语言的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。 <img src="http://upload-images.jianshu.io/upload_images/6383319-b70c4cc018199852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图.png"></li>
<li>程序代码本身可以被映射成为一棵语法树，而通过操纵语法树，我们能够精准的获得程序代码中的每一个精确的节点。例如声明语句，赋值语句，而这是用正则表达式所不能准确体现的地方。<a href="http://esprima.org/demo/parse.html#" target="_blank" rel="external">esprima</a>提供了一个在线解析JavaScript代码的地址，可以清楚地观察到js代码被转化为JSON格式，由一个个具体的符号组成</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>抽象语法树的作用非常的多，比如编译器、IDE、压缩优化代码等。在JavaScript中，虽然我们并不会常常与AST直接打交道，但却也会经常的涉及到它。例如使用UglifyJS来压缩代码，实际这背后就是在对JavaScript的抽象语法树进行操作。<br><img src="http://upload-images.jianshu.io/upload_images/6383319-09faa2604367b873.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图2.png"></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/15/socket-io-实现在线聊天室/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/15/socket-io-实现在线聊天室/" itemprop="url">
                  socket.io 实现在线聊天室
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T10:20:00+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/6383319-ba462293ba9834bb.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图.gif"></p>
<h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4><ul>
<li>WebSocket协议是<strong>基于TCP</strong>的一种新的网络协议。它实现了<strong>浏览器与服务器全双工(full-duplex)通信</strong>——允许服务器主动发送信息给客户端。websocket链接建立后，服务端和客户端可通过连接通道自由通信。wx协议也有类似于https的wss协议，也是多了一层TLS协议。</li>
<li>websocket具体详细的内容就不多做介绍了，因为我这次使用的socket.io框架，写起来的语法和原生websocket语法还是有很大差别的。</li>
</ul>
<h4 id="Socket-io简介"><a href="#Socket-io简介" class="headerlink" title="Socket.io简介"></a>Socket.io简介</h4><ul>
<li>socket.io可以看做是一个对websocket进行了封装的一个框架，目的也是为了实现客户端和服务端的全双工通信。socket.io的底层是engine.io，engine.io在不支持websocket的浏览器中，会使用ajax的长轮询实现效果。</li>
<li>具体过程，浏览器和服务端首先建立xhr链接，第一次握手后，服务端返回浏览器一个upgrades字段，告诉前端可以升级为websocket协议，socket.io客户端的框架会进行环境监测支持websocket的话，就会将xhr链接升级为websocket。建立起一个websocket连接后，服务器和浏览器之间还会定期的ping-pong来确定网络链接是否正常。</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li>再来看下具体实现的代码如何写，<a href="https://socket.io/" target="_blank" rel="external">socket.io官网</a>上面的文档和教程还是挺详细的，而我们要实现这个多人聊天室也只需要其中一些比较基本的api即可。</li>
</ul>
<h4 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h4><ul>
<li><p>服务端我用的node，直接用Npm安装socket.io，可以用socket.io直接搭建服务器，也可以在原有的express/koa上部署，我之前用的express，这里就是将socket.io添加到原有的express服务器上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">let app = new (require(&apos;express&apos;))()</div><div class="line">const server = app.listen(8081, () =&gt; &#123;</div><div class="line">  let peopleCounts = 0</div><div class="line">  let io = require(&apos;socket.io&apos;)(server)</div><div class="line">  io.on(&apos;connection&apos;, function (client) &#123;</div><div class="line">    // 这里的作用域是局部的，针对一个窗口发起的ws链接</div><div class="line">    ++peopleCounts</div><div class="line">    let uname = &apos;&apos;</div><div class="line">    let uColor = require(&apos;./methods/util&apos;).getColor()</div><div class="line"></div><div class="line">    client.on(&apos;disconnect&apos;, function (e) &#123;</div><div class="line">      --peopleCounts</div><div class="line">      io.emit(&apos;sys message&apos;, &#123;</div><div class="line">        data: `系统消息: &quot;$&#123;uname&#125;&quot;离开聊天室`,</div><div class="line">        counts: peopleCounts</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    require(&apos;./methods/getNickName&apos;)()</div><div class="line">      .then(name =&gt; &#123;</div><div class="line">        uname = name</div><div class="line">        io.emit(&apos;initUser&apos;, &#123;</div><div class="line">          name,</div><div class="line">          color: uColor</div><div class="line">        &#125;)</div><div class="line">        io.emit(&apos;sys message&apos;, &#123;</div><div class="line">          data: `系统消息: &quot;$&#123;name&#125;&quot;进入聊天室`,</div><div class="line">          counts: peopleCounts</div><div class="line">        &#125;)</div><div class="line">      &#125;)</div><div class="line">      .catch(e =&gt; &#123; console.log(e) &#125;)</div><div class="line"></div><div class="line">    client.on(&apos;chat message&apos;, function (data) &#123;</div><div class="line">      io.emit(&apos;message from server&apos;, data)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">  console.log(&apos;Example app listening on port 8081!&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>在express服务器搭建成功的回调函数里绑定socket.io，这里的io变量就是表示socket.io的服务端。</p>
</li>
<li>.on方法监听事件，这些事件来自建立websocket连接时或者浏览器端主动触发。</li>
<li>.emit触发事件，前端可以监听这些事件。比如一个客户端连接到服务端时，服务端会生成一个随机昵称(getNickName方法非必要)，然后返回给客户端。</li>
</ul>
<h4 id="客户端部署"><a href="#客户端部署" class="headerlink" title="客户端部署"></a>客户端部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">import io from &apos;socket.io-client&apos;</div><div class="line">export default &#123;</div><div class="line">  name: &apos;cheatRoom&apos;,</div><div class="line">  data () &#123;</div><div class="line">    return &#123;</div><div class="line">      description: &apos;&apos;,</div><div class="line">      nickName: &apos;&apos;,</div><div class="line">      counts: 1,</div><div class="line">      msg: [],</div><div class="line">      color: &apos;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  created () &#123;</div><div class="line">    window.vm = this</div><div class="line">    this.initSocket()</div><div class="line">  &#125;,</div><div class="line">  beforeDestroy () &#123;</div><div class="line">    // socket链接与vue生命周期绑定，vue销毁时手动断开socket链接</div><div class="line">    this.socket.close()</div><div class="line">  &#125;</div><div class="line">  methods: &#123;</div><div class="line">    initSocket () &#123;</div><div class="line">      const socket = io(this._config().preurl)</div><div class="line">      socket.on(&apos;connect&apos;, () =&gt; &#123;</div><div class="line">        this.socket = socket</div><div class="line">      &#125;)</div><div class="line">      // 这里api语法类似于jQuery,支持once监听一次,off取消监听</div><div class="line">      // [https://socket.io/docs/client-api/#socket-on-eventname-callback](https://socket.io/docs/client-api/#socket-on-eventname-callback)</div><div class="line">      socket.once(&apos;initUser&apos;, (&#123;name, color&#125;) =&gt; &#123;</div><div class="line">        this.nickName = name</div><div class="line">        this.color = color</div><div class="line">      &#125;)</div><div class="line">      socket.on(&apos;sys message&apos;, (&#123; data, counts &#125;) =&gt; &#123;</div><div class="line">        this.counts = counts</div><div class="line">        this.msg.push(&#123;</div><div class="line">          description: data,</div><div class="line">          sys: true</div><div class="line">        &#125;)</div><div class="line">      &#125;)</div><div class="line">      socket.on(&apos;message from server&apos;, (item) =&gt; &#123;</div><div class="line">        item.sys = false</div><div class="line">        this.msg.push(item)</div><div class="line">      &#125;)</div><div class="line">    &#125;,</div><div class="line">    loadAction () &#123;</div><div class="line">      let &#123; description, nickName, color &#125; = this</div><div class="line">      if (this.description.length === 0) &#123;</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line">      this.socket.emit(&apos;chat message&apos;, &#123;</div><div class="line">        description,</div><div class="line">        nickName,</div><div class="line">        color</div><div class="line">      &#125;)</div><div class="line">      this.description = &apos;&apos;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>前端需要用npm安装socket.io-client，不能直接使用原生的websocket语法建立连接。</li>
<li>初始化时this._config().preurl是写在配置里的一个url地址，同其他接口地址前缀一样，但是这里的url地址是http协议，也就是说一开始是把一个http协议地址传给的socket.io，然后socket.io在建立http链接之后才升级成的websocket链接。</li>
<li>on方法，用来监听来自服务端的事件，once表示监听一次，还可以取消监听</li>
<li>emit触发事件，让服务端响应。这里的loadAction就表示发送信息。</li>
</ul>
<hr>
<p>2017/11/24 更新</p>
<ul>
<li>客户端我用的vue-cli搭建的项目，整个聊天室就是在一个vue实例中，socket连接与vue实例的生命周期绑定，created的时候建立连接，beforeDestroy的时候断开连接</li>
</ul>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><ul>
<li>整体写法有点像观察者模式，服务端和客户端都是以监听/触发事件的形式完成通信，完全不同于传统的ajax交互方式，十分有趣。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/10/微信小程序-scroll-view实现锚点滑动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/10/微信小程序-scroll-view实现锚点滑动/" itemprop="url">
                  微信小程序   scroll-view实现锚点滑动
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T15:41:00+08:00">
                2017-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>最近开始做小程序，通读一遍文档再上手并不算难，但不得不说小程序里还是有一些坑。这里说一下如何实现页面锚点跳转，一个城市列表的效果示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/6383319-104bb55559f4a26b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="city.gif"></li>
<li>因为在微信小程序的环境中不能想在浏览器里设置标签，或者操作dom滚动，传统做法就行不通了，一切都得按小程序的文档来。</li>
<li>一开始我们的做法是使用<strong>boundingClientRect()方法获取每个锚点的坐标</strong>，然后再用wx.pageScrollTo()方法滑动过去。结果发现效果不是很好，因为boundingClientRect方法返回的每个点的坐标会随着屏幕滑动而变化，可能还会引起页面抖动，<strong>最后还是选择<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/scroll-view.html" target="_blank" rel="external">scroll-view(可滚动视图区域)</a><br>组件来实现锚点效果。</strong></li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li><p>具体API就不赘述了，可以去看官方文档，这里讲几个需要注意的地方，下面是一个示意的scroll-view组件代码，上面的几个属性是必须的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;scroll-view scroll-y style=&quot;height: 200px;&quot; bindscroll=&quot;scroll&quot; scroll-into-view=&quot;&#123;&#123;toView&#125;&#125;&quot; &gt;</div></pre></td></tr></table></figure>
</li>
<li><p>scroll-into-view：这个绑定了一个属性，它的值应该是页面元素的id，设置它的值就可以跳转到ID对应的元素那里了。</p>
</li>
<li>scroll-y：添加这个属性标明是竖向滑动的，对应的scroll-x则表示横向滑动，<strong>竖向滑动时scroll-view必须设置一个固定的height</strong></li>
<li>bindscroll：监听滑动，传给他一个事件，滑动时执行该事件</li>
<li>文档上给的属性特别多，暂时只需要上述几个就可实现我们想要的效果。实现原理也很简单，内容部分，每个英文简写的view设置一个id，然后在导航list那里点击时，就把scroll-into-view的值设置成点击的那个id即可实现跳转。</li>
<li>再说一下scroll-view的高度问题，这个一定要做适配的固定高度，不然在不同屏幕大小的手机上的显示效果有差异。</li>
</ul>
<h3 id="几点优化"><a href="#几点优化" class="headerlink" title="几点优化"></a>几点优化</h3><ul>
<li><p>到这里功能基本都实现了，但后面还发现一些问题：如果要隐藏scroll-view的滚动条，需要设置css样式:::-webkit-scrollbar</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">::-webkit-scrollbar &#123;</div><div class="line">	width: 0;</div><div class="line">	height: 0;</div><div class="line">	color: transparent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>还有就是点了一个锚点实现了跳转，这个时候你滚动页面再点之前点的锚点，页面就不会再跳转了，这个时候就需要监听滚动事件，滚动时将scroll-into-view属性的值清空。或者在每次锚点跳转后，再由一个异步操作将scroll-into-view属性的值清空。</p>
</li>
</ul>
<h4 id="2017-12-05补充"><a href="#2017-12-05补充" class="headerlink" title="2017/12/05补充:"></a>2017/12/05补充:</h4><ul>
<li>scroll-view默认是无滑动动画的，需要滚动的动画效果需要在组件上设置：<strong>scroll-with-animation=’true’</strong></li>
<li>关于固定高度height的设置问题，一开始我以为这个高度和滚动元素的数目/高度有关，这个时候处理动态变化的列表就很麻烦。后面在网上看到的一个方法就是使用<strong>wx.getSystemInfo</strong>方法得到windowHeight，把这个设置为scroll-view的高度(单位为px)即可。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/javascript事件流、事件代理、target和currentTarget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TokenYangForever">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐洋洋的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/31/javascript事件流、事件代理、target和currentTarget/" itemprop="url">
                  javascript事件流、事件代理、target和currentTarget
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T09:54:00+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>这篇讲的内容是非常基础的，关于javascript中的事件相关可能不太全面，只是围绕几个知识点。可能现在mvvm框架用多了也不用多去在意dom和event，但是原生的基础知识还是需要掌握的(万一以后面试问到了呢~~)</li>
<li>Javascript与html之间的交互是通过<strong>事件</strong>来实现的。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间，可以用侦听器(或处理程序)来预定事件，以便事件发生时执行相应的代码。</li>
</ul>
<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><ul>
<li><strong>事件流</strong>描述的是从页面接收到事件的顺序，一些历史发展的内容这里就不提了，直接讲”DOM2级事件”，事件流包括三个阶段：<strong>事件捕获阶段、处于目标阶段和事件冒泡阶段</strong>。最先发生的是事件捕获，然后是具体的实际目标收到事件，最后才是冒泡阶段，可以在这个阶段对事件做出响应。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/6383319-f8a239bd4cb8b4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网上找的示意图.png"></p>
<h3 id="添加事件监听"><a href="#添加事件监听" class="headerlink" title="添加事件监听"></a>添加事件监听</h3><ul>
<li><p>给元素添加事件监听的方法，可以直接在html上添加或者在javascript中指定相关的<strong>事件处理程序</strong>，但是需要注意，这种以’on’开头的事件属于’DOM0’级事件，重复定义时会覆盖掉原事件，而使用addEventListener则不会覆盖之前添加的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input id=&apos;btn&apos; value=&apos;click me&apos; onclick=&apos;alert(this.value)&apos;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>还可以使用<strong>addEventListener/removeEventListener</strong>方法，所有dom节点都包含这方法，传入三个参数:事件名、处理事件的函数、标示在捕获还是在冒泡阶段调用回调函数的布尔值。</p>
</li>
<li>addEventListener添加的事件处理函数只能用removeEventListener方法移除，传入参数与addEventListener相同，<strong>意味着addEventListener添加的匿名函数无法移除，</strong>所以在用addEventListener添加处理函数时不能使用匿名函数。环境不支持addEventListener的时候，还可以使用attachEvent/detachEvent，这里就不多做介绍了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let btn = document.getElementById(&apos;btn&apos;)</div><div class="line">let handler = function () &#123;alert(this.id)&#125;</div><div class="line">btn.addEventListener(&apos;click&apos;, handler,false)</div><div class="line">btn.removeEventListener(&apos;click&apos;, handler,false)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><ul>
<li>事件委托是什么呢？最简单来说：<strong>在父元素上添加可以处理子元素事件的事件处理函数</strong>。利用了事件冒泡，指定一个事件处理函数，来处理同一种类型的多个事件。这里顺便一起说下target和currenttarget的区别，<strong>target是触发事件的最具体的元素， currenttarget是绑定事件的元素(在函数中一般等于this)</strong>。下面具体代码示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;outter&quot;&gt;</div><div class="line">   &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var outter = document.querySelector(&apos;#outter&apos;)</div><div class="line">outter.addEventListener(&apos;click&apos;,function(e)&#123;</div><div class="line">    console.log(e.target.id)  //inner</div><div class="line">    console.log(e.currentTarget.id)  //outter</div><div class="line">    console.log(this === e.currentTarget)  //true</div><div class="line">&#125;,false);</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="TokenYangForever" />
          <p class="site-author-name" itemprop="name">TokenYangForever</p>
           
              <p class="site-description motion-element" itemprop="description">放点随笔文章</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TokenYangForever</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
